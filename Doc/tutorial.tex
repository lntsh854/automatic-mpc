\documentclass[a4paper,titlepage,11pt,twosides,floatssmall]{article}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[OT1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tikz}
\usetikzlibrary{arrows,calc,decorations.markings,math,arrows.meta}
\usepackage{rotating}
\usepackage[percent]{overpic}
\usepackage[cp1250]{inputenc}
\usepackage{xcolor}
\usepackage{pgfplots}
\usetikzlibrary{pgfplots.groupplots}
\usepackage{listings}
\usepackage{matlab-prettifier}
\usepackage{enumitem,amssymb}
\definecolor{szary}{rgb}{0.95,0.95,0.95}
\usepackage{siunitx}
\sisetup{detect-weight,exponent-product=\cdot,output-decimal-marker={,},per-mode=symbol,binary-units=true,range-phrase={-},range-units=single}
\SendSettingsToPgf
%konfiguracje pakietu listings

\lstset{
	escapeinside = {@}{@},
	breaklines=true,
	tabsize=2,
	captionpos=t,
	xleftmargin=2pt,
	showstringspaces=false,
	aboveskip=0em,
  belowskip=0em,
  basicstyle=\footnotesize\ttfamily,
}

\lstdefinestyle{customlatex}{
	basicstyle=\footnotesize\ttfamily,
	%basicstyle=\small\ttfamily,
}

\definecolor{matlabtext}{HTML}{000000}
\definecolor{matlabbg}{HTML}{FFFFFF}
\definecolor{matlabkeywords}{HTML}{0000FF}
\definecolor{matlabcomments}{HTML}{228B22}
\definecolor{matlabstring}{HTML}{A020F0}
\definecolor{matlaberror}{HTML}{FF0000}
\definecolor{matlabvariable}{HTML}{000000}

\lstdefinestyle{myc}{
	language=C,
	backgroundcolor=\color{white},
	keywordstyle=\bfseries\color{green!40!black},
	commentstyle=\itshape\color{purple!40!black},
	identifierstyle=\color{blue},
	stringstyle=\color{orange},
	classoffset=1,% starting a new class
%	alsoletter=\#,
	otherkeywords={\#MPC\_BEGIN, \#MPC\_END, \#MPC\_INCLUDE, \#MPC\_PROFILER\_BEGIN, \#MPC\_PROFILER\_COUNT, \#MPC\_PROFILER\_END, \#MPC\_PROFILER\_PRINT},	
	morekeywords=[2]{\#MPC\_BEGIN,\#MPC\_END},
	keywordstyle=[2]\bfseries\color{orange},
	morekeywords=[3]{\#MPC\_PROFILER\_BEGIN, \#MPC\_PROFILER\_COUNT, \#MPC\_PROFILER\_END, \#MPC\_PROFILER\_PRINT},
	keywordstyle=[3]\bfseries\color{purple},
	morekeywords=[4]{\#MPC\_INCLUDE},
	keywordstyle=[4]\bfseries\color{red}, % not used anymore	
	morekeywords=[5]{CurrentControlPtr,CurrentControl},
	keywordstyle=[5]\bfseries\color{green!50!blue}, % not used anymore	
	morekeywords=[6]{ArchiveDataPtr,ArchiveData},
	keywordstyle=[6]\bfseries\color{green!50!red}, % not used anymore	
}
\lstdefinestyle{mym}{
	language=matlab,
	backgroundcolor=\color{white},
	basicstyle=\footnotesize\ttfamily\color{matlabtext},
	keywordstyle=\bfseries\color{matlabkeywords},
	commentstyle=\color{matlabcomments},
	morecomment=[l][\color{matlabcomments}\bfseries]{\%\%},
	morecomment=[l][\color{matlabcomments}]{...},
	identifierstyle=\color{matlabvariable},
	stringstyle=\color{matlabstring},
}

%wymiar tekstu (bez ¿ywej paginy)
\textwidth 160mm \textheight 247mm

%ustawienia pakietu pgfplots
\pgfplotsset{
tick label style={font=\scriptsize},
label style={font=\small},
legend style={font=\small},
title style={font=\small}
}

\newcommand{\AutomaticMPC}{{\scshape AutoMATiC}}

\title{\AutomaticMPC\ -- Tutorial}
\author{Patryk Chaber}
\date{\today}

\begin{document}
\maketitle

\tableofcontents
\newpage
\section{Introduction}
\section{Requirements}
This software was tested using following setup:
\begin{itemize}
\item Microsoft Windows 10 Pro
\item MATLAB 2019a
\item MinGW64 Compiler (C++)
\end{itemize}
and for the programming of the exemplary microcontroller:
\begin{itemize}
\item STM32F746IGT6 microcontroller (part of the Core7XXI evaluation board with Open7XXI-C board -- both produced by WaveShare)
\item J-Link v9.3
\item Keil uVision v5.17.0.0
\item STM32CubeMX
\end{itemize}

Despite aforementioned configuration, this software was tested with MATLAB 2017b, thus should work with any other MATLAB version in between of those two. This software should work also on Linux based operating systems, but it may require minor changes in paths notation.

\section{Installation}
To build \AutomaticMPC\ system compile its sources using \lstinline[style=mym]{mex} compiler in MATLAB with following steps:
\begin{enumerate}
\item download or clone the repository of \AutomaticMPC:\\ \url{https://github.com/pjchaber/automatic-mpc.git}
\item make sure that MATLAB is callable from the shell by executing: \label{it:shell}
\begin{lstlisting}[]
matlab -batch "disp(version);"
\end{lstlisting}
which should print output similar to the following:
\begin{lstlisting}[]
9.6.0.1072779 (R2019a)
\end{lstlisting}
If the output differs, make sure that the following MATLAB directory:
\begin{lstlisting}[]
<MATLAB root directory>\bin\win64
\end{lstlisting}
is listed in \lstinline|PATH| variable of your system. For example:
\begin{lstlisting}[]
E:\Program Files\MATLAB\R2019a\bin\win64
\end{lstlisting}
\item register MATLAB for further use of its engine executing of the following instruction in shell:\label{it:regserver}
\begin{lstlisting}[]
matlab -regserver
\end{lstlisting}
\item change current working directory to a directory with the source of the project 
\item execute in MATLAB following instruction
\begin{lstlisting}[style=mym]
mex -v -client engine main.cpp XGetOpt.cpp -output automatic_transcompiler.exe;;
\end{lstlisting}
If the compilation fails, make sure that you have set a C++ compiler by executing in MATLAB:
\begin{lstlisting}[style=mym]
mex -setup C++
\end{lstlisting}
Also make sure, to use the same MATLAB version which was used in the shell at step \ref{it:shell} and \ref{it:regserver}.
\end{enumerate}

\section{Setup}
All further examples focus on the task of controlling output voltage of emulated process. It is also done using voltage signals. All those signals range from 0 to 3.3V. From the implementation side, those signals are represented as values from -1 to 1, where the lowest value represents 0V and the highest one represents 3.3V. The process that is emulated is a matrix of single inertia transfer functions. {\color{red} Should I give an exact process definition or the code for one?}

\section{Single Algorithm in a Controller}

Firstly lets create STM32CubeMX project which will be used as a base for further definition of a target platform's configuration (it is expected from the reader to know how to use STM32CubeMX and how to create projects for STM32F746IGT6 or similar, and how to, based on such a project, generate a Keil uVision 5 project). Details of this project are as follows:
\begin{itemize}
	\item Target Platform: STM32F746IGTx
	\item Pinout and Configuration:
	\begin{itemize}
		\item RCC (HSE as Crystal/Ceramic Resonator)
		\item ADC3 (IN0 and IN1 enabled):
		\begin{itemize}
			\item Clock Prescaler: PLCK divided by 4
			\item Scan Conversion: Enabled
			\item Continuous Conversion: Enabled
			\item DMA Continuous Requests: Enabled
			\item Number of Regular Conversions: 2
			\item Rank 1:
			\begin{itemize}
				\item Channel: Channel 0
				\item Sampling Time: 144 Cycles
			\end{itemize}
			\item Rank 2:
			\begin{itemize}
				\item Channel: Channel 1
				\item Sampling Time: 144 Cycles
			\end{itemize}
		\end{itemize}
		\item DAC (OUT1 and OUT2 enabled), for both outputs:
		\begin{itemize}
			\item  Output Buffer: Enable
			\item  Trigger: None
		\end{itemize}
		\item TIM2 (Clock Source: Internal Clock):
		\begin{itemize}
			\item Prescaler: 1000-1
			\item Counter Period: 10800
		\end{itemize}
		\item TIM5 (Clock Source: Internal Clock):
		\begin{itemize}
			\item Prescaler: 0
			\item Counter Period: 0xffffffff
		\end{itemize}
		\item USART1 (Asynchronous):
		\begin{itemize}
			\item Data Direction: Transmit Only
		\end{itemize}
		\item DMA2
		\begin{itemize}
			\item ADC3:
			\begin{itemize}
				\item Stream: DMA2 Stream 0
				\item Direction: Peripheral to Memory
				\item Priority: Low
				\item Mode: Circular
				\item Peripheral Data Width: Word
				\item Memory Data Width: Word
			\end{itemize}
			\item ADC3:
			\begin{itemize}
				\item Stream: DMA2 Stream 0
				\item Direction: Peripheral to Memory
				\item Priority: Low
				\item Mode: Circular
				\item Peripheral Data Width: Word
				\item Memory Data Width: Word
			\end{itemize}
		\end{itemize}
		\item NVIC:
		\begin{itemize}
			\item Time base of System tick Timer (Preemption Priority: 5)
			\item ADC1, ADC2 and ADC3 global interrupts (Enable, Preemption Priority: 3)
			\item TIM2 global interrupts (Enabled, Preemption Priority: 1)
			\item USART1 global interrupts (Enabled)
			\item DMA2 stream0 global interrupts (Preemption Priority: 4)
		\end{itemize}
	\end{itemize}
	\item Clock Configuration:
	\begin{itemize}
		\item Input Frequency for HSE: 8Hz
		\item PLL Source Mux: HSE
		\item HCLK (MHz): 216 (confirm by pressing ENTER)
	\end{itemize}
	\item Project Manager:
	\begin{itemize}
		\item Toolchain / IDE: MDK-ARM V5
		\item Minimum Heap Size: 0x8000
		\item Minimum Stack Size: 0x40000
	\end{itemize}
\end{itemize}

After generating code to a Keil uVision 5 project communication interface with the PC and interface to connect process of control has to be implemented. It is worth making sure, that all the code, that is added to the project after its generation is placed between comments \lstinline[style=myc]|/* USER CODE BEGIN <name> */| and \lstinline[style=myc]|/* USER CODE END <name> */|, which will further on be denoted as "\textless name\textgreater" block. It will further ease the process of regeneration of the microcontroller's configuration.

\subsection{Communication with PC using USART}
Firstly, in the \lstinline[]|main.c| file, \lstinline|string.h| library header has to be included in the "Includes" block. This will allow to send text messages to a PC in a simple manner. Next a simple wrapper for transmitting of a string should be defined in block "0":
\begin{lstlisting}[style=myc]
void write_string(char * txt){
	while(HAL_UART_GetState(&huart1) == HAL_UART_STATE_BUSY_TX);
	if(HAL_UART_Transmit_IT(&huart1, (uint8_t*)txt, strlen(txt))!= HAL_OK) 
		Error_Handler();  
	while(HAL_UART_GetState(&huart1) == HAL_UART_STATE_BUSY_TX);
}
\end{lstlisting}

At this point, it is possible to send text messages to a PC, it is worth noting, that the new line character and carriage return is not included by default in the sent string.
\subsection{Measuring Voltage Signal}
Voltage signals after conversion to a digital values will be averaged over 100 consecutive samples. Therefore a table for those raw measurements have to be defined in block "PV" as:
\begin{lstlisting}[style=myc]
uint32_t adc_val_raw[ADC_SIZE*2] = {0};
\end{lstlisting}
where \lstinline[style=myc]|ADC_SIZE| is defined in block "PD" as:
\begin{lstlisting}[style=myc]
#define ADC_SIZE 100
\end{lstlisting}
Due to having two signals, the size of table with raw measurements is \lstinline[style=myc]|ADC_SIZE*2|. To increase the resolution of averaged measurements, those will be stored as \lstinline[style=myc]|float| variables (block "PV"):
\begin{lstlisting}[style=myc]
float adc_val_f[2] = {0,0};
\end{lstlisting}

Having those defined, it is important to start a ADC unit. It can be implemented by inserting following code into a block "2":
\begin{lstlisting}[style=myc]
HAL_ADC_Start(&hadc3);
if(HAL_ADC_Start_DMA(&hadc3, (uint32_t*)adc_val_raw, ADC_SIZE*2) != HAL_OK) Error_Handler();
\end{lstlisting}

Thanks to a DMA mechanism, after obtaining 100 consecutive samples of each signal a specific callback function will be executed. It can be redefined to perform measurements' averaging as soon as they are available, by inserting following code in block "0":
\begin{lstlisting}[style=myc]
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* AdcHandle)
{
	static int i=0; 
	static uint32_t tmpval[2] = {0,0};
	for(i=0,tmpval[0]=0,tmpval[1]=0;i<ADC_SIZE; ++i){
		tmpval[0] += adc_val_raw[2*i];
		tmpval[1] += adc_val_raw[2*i+1];
	}
	adc_val_f[0] = ((float)tmpval[0]/ADC_SIZE-2047.5f)/2047.5f;
	adc_val_f[1] = ((float)tmpval[1]/ADC_SIZE-2047.5f)/2047.5f;
}
\end{lstlisting}
This will allow to have constant supply of averaged results from ADC without consuming much of a computational power of a microcontroller core (thanks to DMA).

\subsection{Creating Voltage Signal}
To generate voltage signal DAC are used. Those are already configured thanks to the generation of the code from STM32CubeMX, although, they have to be started before they can be used. To start them, in the block "2" there has to be invoked:
\begin{lstlisting}[style=myc]
HAL_DAC_Start(&hdac, DAC_CHANNEL_1);
HAL_DAC_Start(&hdac, DAC_CHANNEL_2);
\end{lstlisting}
A following calls allow to generate 0V on first output, and the 3.3V on the second one, since this is a 12 bit DAC:
\begin{lstlisting}[style=myc]
HAL_DAC_SetValue(&hdac, DAC1_CHANNEL_1,DAC_ALIGN_12B_R,0);
HAL_DAC_SetValue(&hdac, DAC1_CHANNEL_2,DAC_ALIGN_12B_R,4095);
\end{lstlisting}
and thus, to use this with a variable that ranges from -1 to 1, a following function is defined (in block "WHILE"):
\begin{lstlisting}[style=myc]
void __setControlValue(float* value){
  HAL_DAC_SetValue(&hdac, DAC1_CHANNEL_1,DAC_ALIGN_12B_R, (uint32_t)(value[0]*2047.5f+2047.5f));
  HAL_DAC_SetValue(&hdac, DAC1_CHANNEL_2,DAC_ALIGN_12B_R, (uint32_t)(value[1]*2047.5f+2047.5f));
}
\end{lstlisting}
where an array of two floats is an argument, and it contains values for consecutive outputs.

\subsection{Inducing Interruptions with a Constant Frequency}
To generate an interruption with a constant frequency, which will further be used as an indicator of the beginning of new discrete time, a timer TIM2 is used. It is already configured to generate events with a constant period of 100ms, but it is not started yet. To do so, a following must be implemented in a block "2":
\begin{lstlisting}[style=myc]
HAL_TIM_Base_Init(&htim2);   
HAL_TIM_Base_Start_IT(&htim2);
\end{lstlisting}
This will cause an execution of a callback function which can be redefined:
\begin{lstlisting}[style=myc]
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
    if (htim->Instance == TIM2) {
		// interrupt each 100ms
    }
}
\end{lstlisting}
Although its implementation will be further extended.
\subsection{Interface for Further Ease of Use}
At this point it is worth to create additional functions, that will wrap already existing functionality, so that anyone who will be working with this project in terms of control algorithms, will have easy interface to work with. Firstly, to give access to measurements signals a following will be used (block "0"):
\begin{lstlisting}[style=myc]
float* __measureOutput(){	
	return adc_val_f;
}
\end{lstlisting}
and it will return a pointer to a two element array of measurement values. It is clearly visible, that it is analogous to the previously defined \lstinline[style=myc]|void __setControlValue(float* value)| function. Those two functions have to have their declarations in the header file corresponding to the source file in which they are defined (block "EFP" in \lstinline|main.h|). In this header, it could be convenient to declare also a function for communication with a PC \lstinline[style=myc]|void write_string(char * txt)|.

Because the main function of the program (namely \lstinline[style=myc]|int main(void)|) is defined in the \AutomaticMPC\ system software framework, the existing one have to be redefined using another name, e.g. \lstinline[style=myc]|void low_lvl_main(void)|, which of course also has to be accessible from other source files. Therefore its declaration has to be given in a proper header file.

At the end it will be convenient to set up the Keil uVision 5 project in such a way, the transcompilation process is executed always right before the build process starts. For this, "Options for Target" window has to be opened, and in the "User" tab, in "Before Build/Rebuild" a "Run \#1" has to be filled with an execution of the transcompiler. A following will be used:
\begin{lstlisting}
<absolute path to AutoMATiC>/automatic_transcompiler.exe -I -p -d -i ../Src/main.mpc -o ../Src/main_mpc.c -l <absolute path to AutoMATiC>/Libs/MATLAB/ -L <absolute path to AutoMATiC>/Libs/C/
\end{lstlisting}
It is worth noting, that the transcompiler is executed while being in the directory with a project file (i.e. \lstinline|MDK-ARM|). Consecutive arguments of the \lstinline|automatic_transcompiler.exe| execution denotes:
\begin{itemize}
\item \lstinline|-I| -- usage of the interrupt based software framework variant,
\item \lstinline|-p| -- usage of the profiler,
\item \lstinline|-d| -- usage of the forced delay of the control signal application,
\item \lstinline|-i <path>| -- relative path to the input file used for transcompilation,
\item \lstinline|-o <path>| -- relative path to the output file storing the result of transcompilation,
\item \lstinline|-l <path>| -- relative path to the directory with MATLAB libraries of the transcompiler,
\item \lstinline|-L <path>| -- relative path to the directory with C libraries of the transcompiler.
\end{itemize}

To complete the setup of the project one has to add source files and headers of \AutomaticMPC\ system to a project for further compilation. All these files can be found in a directory \lstinline|<absolute path to AutoMATiC>/Libs/C/|. Also a file named \lstinline|main.mpc| has to be created and placed in the \lstinline|../Src/| directory. This file will contain all the logic of the controller with as few low level implementation parts as possible.

\subsection{Logic of the Controller}
The file that contains logic of the controller, namely \lstinline|main.mpc|, contains implementations which can be divided in a few parts:
\begin{itemize}
\item utilisation of the low level interface functions,
\item invoke of the MATLAB script, used for automatic code generation of the MPC algorithm,
\item implementation of controllers behaviour.
\end{itemize}
The execution of the MATLAB script is not necessary -- content of this script could be as well placed right here. This notation nevertheless allows for clearer separation of the aforementioned parts of implementation of this file:

\begin{lstlisting}[style=myc]
#include "stm32f7xx_hal.h"
#include <string.h>
#include "main.h"
#include "mat_lib.h"

ArchiveData ad;
CurrentControl cc;

long get_time(){ return HAL_GetTick(); }

extern void timer_loop(void);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
    if (htim->Instance == TIM2) {
        timer_loop();
    }
}
void measurements(){
    #MPC_PROFILER_BEGIN 4
    new_output(&ad,__measureOutput());
    #MPC_PROFILER_END 4
}
void controls(){
    #MPC_PROFILER_BEGIN 3
    __setControlValue(last_control(&ad));
    #MPC_PROFILER_END 3
}
void hardware_setup(){
    #MPC_PROFILER_BEGIN 1
    low_lvl_main();
    #MPC_PROFILER_END 1
}

#MPC_BEGIN
\end{lstlisting}
\begin{lstlisting}[style=mym]
% Here is the MATLAB code
algorithms_parameters_definitions
\end{lstlisting}
\begin{lstlisting}[style=myc]
#MPC_END

void controller_setup(){
    #MPC_PROFILER_BEGIN 2
    init_archive_data(&ad, 200, 200, 2, 2, 0, 0, 0.01);
    init_current_control(&cc,&ad);
    controller(NULL,NULL);
    #MPC_PROFILER_END 2
}

void idle(){
    #MPC_PROFILER_BEGIN 13
    const int k = 0;
	static char str[1000] = {0};

    sprintf(str, "x = [%f,%f,",ad.y[k][0], ad.y[k][1]);    write_string(str);
    sprintf(str,      "%f,%f,",ad.z[0], ad.z[1]);          write_string(str);
    sprintf(str,      "%f,%f,",ad.u[k-1][0],ad.u[k-1][1]); write_string(str);
    write_string("];\n\r");
    #MPC_PROFILER_END 13
}

void loop(){
    #MPC_PROFILER_BEGIN 10
    static int i = 0;
	if(i<  50){ ad.z[0] = -0.1; ad.z[1] =  0.2; }
	else      { ad.z[0] =  0.1; ad.z[1] = -0.2; }
    if(++i > 100) i = 0;
	
    #MPC_PROFILER_BEGIN 50
	controller(&ad,&cc);
	#MPC_PROFILER_END 50
	
    push_current_controls_to_archive_data(&cc,&ad);	
    #MPC_PROFILER_END 10		
}

void timeout(){
    while(1);
}
\end{lstlisting}

On the listing, there is a reference to a function called \lstinline[style=myc]|controller|, which declaration is as follows:
\begin{lstlisting}[style=myc]
void controller(ArchiveData * ad, CurrentControl * c);
\end{lstlisting}
This function will be generated as soon as the MATLAB script is finished.

The \AutomaticMPC\ system software framework assumes that there is an implementation of functions:
\begin{itemize}
\item \lstinline[style=myc]|void write_string(char * str);| -- function used by the profiler to write out the results of its measurements,
\item \lstinline[style=myc]|long get_time(void);|  -- function used by the profiler to measure time of execution,
\item \lstinline[style=myc]|void hardware_setup(void);| -- function used to setup hardware configuration of the controller,
\item \lstinline[style=myc]|void controller_setup(void);| -- function used to setup software configuration of the controller,
\item \lstinline[style=myc]|void measurements(void);| -- function used to obtain measurements for the current controller iteration,
\item \lstinline[style=myc]|void loop(void);| -- function used to define the behaviour of the controller -- here control algorithms are executed,
\item \lstinline[style=myc]|void controls(void);| -- function used to determine what to do with results obtained from consecutive control algorithms,
\item \lstinline[style=myc]|void idle(void);| -- function used for other, lower prioritized procedures,
\item \lstinline[style=myc]|void timeout(void);| -- function executed when the iteration lasts longer than the sampling period.
\end{itemize}
These functions are used in the framework, in the predefined order. If some of these are not implemented, a default (often empty) implementation is assumed.

To implement interrupt based variant of the software framework, a function
\begin{lstlisting}[style=myc]
extern void timer_loop(void);
\end{lstlisting}
has to be declared, and called each time a new discrete time instant starts. In these examples it occurs each time, the timer TIM2 generates an interrupt, and thus causes execution of the following function:
\begin{lstlisting}[style=myc]
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);
\end{lstlisting}

Each new measurement has to be stored in the \lstinline[style=myc]|ArchiveData| structure, using
\begin{lstlisting}[style=myc]
void new_output(ArchiveDataPtr ad, float* y);
\end{lstlisting}
function. Also the final values of new control signals have to be stored in the same structure using 
\begin{lstlisting}[style=myc]
void push_current_controls_to_archive_data(CurrentControlPtr c,ArchiveDataPtr ad);
\end{lstlisting}
where \lstinline[style=myc]|CurrentControl| structure is filled by each control algorithm.

Lastly, there are a few functions in the \lstinline[style=myc]|void controller_setup()| function, that are necessary to use those two structures. A function 
\begin{lstlisting}[style=myc]
void init_archive_data(ArchiveDataPtr ad, 
	long number_of_u, long number_of_y, 
	long size_of_u, long size_of_y, 
	float default_u, float default_y, 
	float current_yzad);
\end{lstlisting}
is used to initialize the \lstinline[style=myc]|ArchiveData| instance. First argument is a pointer to this structure instance, next there are two parameters used to define number of control and output signals (in this order) of the process of control. Further there are two values that determine, how many previous values of control and output signals have to be stored in the memory of the controller. At the end, there are default values of control, output and set-point signal, used for initialization of the microcontroller memory -- those can be changed as soon as the initialization function is finished.

Next function is
\begin{lstlisting}[style=myc]
void init_current_control(CurrentControlPtr cc, ArchiveDataPtr ad);
\end{lstlisting}
which is used to allocate memory for an instance of \lstinline[style=myc]|CurrentControl| based on the data stored in the alreaty setup \lstinline[style=myc]|ArchiveData| instance.

At the end of the software setup, there is an execution of the controller function, with both parameters set to \lstinline[style=myc]|NULL|, which is used to initialize some values of the controller that are constant through its whole existence -- this will be clear as soon as the generated code of the algorithm appears.

\subsection{Dynamic Matrix Control -- Analytic version}
From this point on, only the \lstinline[style=myc]|algorithms_parameters_definitions.m| will be modified in order to generate various control algorithms' implementations. It is important to make sure that this script is placed in the \lstinline|Src| directory of the Keil uVision 5 project. All further algorithms will be used to control output signals of the process described with the following transfer function:
\begin{equation}
G(s) = \left[\begin{array}{cc}
\displaystyle\tfrac{5}{0.14s+1} & \displaystyle\tfrac{1}{0.10s+1} \\[1mm]
\displaystyle\tfrac{1}{0.06s+1} & \displaystyle\tfrac{2}{0.08s+1} \\
\end{array}\right]
\end{equation}
Based on this transfer function one can derive various discrete time models, specifically model in form of step response coefficients (which is required by the DMC algorithm) or a set of difference equations (used in the GPC algorithm). First one must create a continuous time transfer function in MATLAB:
\begin{lstlisting}[style=mym]
clear all
%% Process definition
Gs  = [... 
    tf(5,[.14,1]),tf(1,[.10,1]);...
    tf(1,[.06,1]),tf(2,[.08,1]);...
];               % continuous transfer function
\end{lstlisting}
It is worth to clear the workspace at the beginning of this script in order to avoid problems with accidental use of old variables. Next this transfer function have to be transformed into a discrete time one, and thus following have to be executed:
\begin{lstlisting}[style=mym]
Gz = c2d(Gs,0.1); % discrete transfer function
ny = 2; % number of output signals
nu = 2; % number of control signals
\end{lstlisting}
Additional definition of the number of output and control signals is just for the cleaner code in further part of this script. For the discretization, a sampling time of 0.1 s was used.

To determine step response coefficients a \lstinline[style=mym]|step| function of MATLAB could be used, but results would have to be modified in the convenient way. For the sake of clarity, this script does not utilize this function, it calculates this coefficients based on the GPC model instead. Therefore the ARX model used in GPC will be determined firstly:

\begin{lstlisting}[style=mym]
for m=1:2 % ARX model determination
    tmpa = conv(Gz.Den{m,1},Gz.Den{m,2}); GPC_a(m,:)   = tmpa(2:end);
    tmpb = conv(Gz.Num{m,1},Gz.Den{m,2}); GPC_b(m,1,:) = [tmpb(2:end) 0]; 
    tmpb = conv(Gz.Num{m,2},Gz.Den{m,1}); GPC_b(m,2,:) = [tmpb(2:end) 0];
end
\end{lstlisting}

This script cannot be used for a process with a different dimensionality -- a more general approach would be necessary. Next, the dynamics horizon is defined, and the step response is obtained:
\begin{lstlisting}[style=mym]
D = 5;  % dynamics horizon
S = step_response_generation(GPC_a,GPC_b,D);
\end{lstlisting}
and the \lstinline[style=mym]|step_response_generation| is defined at the end of this script as follows:

\begin{lstlisting}[style=mym]
function S = step_response_generation(GPC_a,GPC_b,D)
    ny = size(GPC_a,1);
    nu = size(GPC_b,2);
    S = zeros(ny,nu,D);
    for k = 1:size(S,3)
        for m=1:ny
            for n=1:nu
                for i=1:min(k,size(GPC_b,3))
                    S(m,n,k) = S(m,n,k) + GPC_b(m,n,i)*1;
                end
                for i=1:min(k-1,size(GPC_a,2))
                    S(m,n,k) = S(m,n,k) - GPC_a(m,i)*S(m,n,k-i);
                end         
            end   
        end 
    end
    % adding a single iteration of delay
    S(:,:,2:end+1) = S(:,:,1:end); 
    S(:,:,1) = S(:,:,1)*0; 
end
\end{lstlisting}

Here, a set of general parameters of MPC algorithms is defined:
\begin{lstlisting}[style=mym]
% General control algorithms' parameters
N  = 5; % prediction horizon
Nu = 5; % control horizon
lambda= [1.0 1.0]; % Penalty--control signals' increments
psi   = [1.0 1.0]; % Penalty--control errors
dumin =-[.01 .01]; % Lower bound--control increments
dumax = [.01 .01]; % Upper bound--control increments
umin  =-[1.0 1.0]; % Lower bound--control signal
umax  = [1.0 1.0]; % Upper bound--control signal
\end{lstlisting}

and lastly, and automatic code generation procedure is called:
\begin{lstlisting}[style=mym]
AutoMATiC_Generate('AutoMATiC_DMC_Analytic_Algorithm','controller');
\end{lstlisting}
This function is defined in the script in \lstinline|<path to AutoMATiC>/Libs/MATLAB/|. Three arguments at most can be passed to this function, in the following order: the name of the algorithm, which definition will be used to generate C code (it corresponds to the name of the script with an algorithm definition -- these can be found in the \lstinline|<path to AutoMATiC>/Libs/MATLAB/| directory), the name of the generated C function, and a binary logic value which defines if there will be more algorithms generated in the same MATLAB script. The meaning of the last parameter will be clear in the example where two algorithms are generated for one controller project. 

At this point, if the build procedure will be called on the Keil uVision5 project, the automatic code generation will be called first, which will generate a file called \lstinline|main_mpc.c|, which can be found in the appendix \ref{ch:dmca}.

As it is visible, the \lstinline|<path to AutoMATiC>| in this example is \lstinline|C:\Users\Admin\Documents\GitHub\AutoMATiC|. It is worth noting, that there is no part where the MATLAB code could be placed, instead there is a definition of the \lstinline[style=myc]|void controller(ArchiveData * ad, CurrentControl * c)| function. Also each pair of \lstinline[style=myc]|#MPC_PROFILER_BEGIN <id>| and \lstinline[style=myc]|#MPC_PROFILER_END <id>| is substituted with a pair of corresponding C functions \lstinline[style=myc]|profiler_start(<id>)| and \lstinline[style=myc]|profiler_end(<id>)|. If this generated C language source file is not included in the project and the build fails -- it is necessary to add this file to the project and repeat the building process. At this point everything should be ready to program the microcontroller, and test the controller itself.

\subsection{Dynamic Matrix Control -- Numeric version}
Based on the already created project for analytical version of DMC algorithm, a change to its numeric version is straightforward. It only requires the change od the name of used algorithm, i.e. a following line from the \lstinline|algorithms_parameters_definitions.m| script:
\begin{lstlisting}[style=mym]
AutoMATiC_Generate('AutoMATiC_DMC_Analytic_Algorithm','controller');
\end{lstlisting}
has to be changed to:
\begin{lstlisting}[style=mym]
AutoMATiC_Generate('AutoMATiC_DMC_Numeric_Algorithm','controller');
\end{lstlisting}
which, after performing same tasks as before to generate the final pure C code, will result in the code listed in the appendix \ref{ch:dmcn}.

\section{Multiple Algorithms in a Controller}
\subsection{Analytic and Numeric versions of DMC}
To implement a simple controller, which contains two different algorithms, e.g. DMC in two versions, analytical and numerical, it is required to perform some minor changes both in the controllers' logic (\lstinline|main.mpc|), and the MATLAB script that defines parameters of used algorithms (\lstinline|algorithms_parameters_definitions.m|). In the logic part, a new global variable, e.g. \lstinline[style=myc]|int algorithm_used = 0;| should be created -- it will define, which algorithm is currently used. Next, the switching logic should be implemented -- in the \lstinline[style=myc]|void loop()| function a simple condition will be added:
\begin{lstlisting}[style=myc]
if(algorithm_used == 0) controllerDMCA(&ad,&cc);
else                    controllerDMCN(&ad,&cc);
\end{lstlisting}
which will define, that if the variable \lstinline[style=myc]|algorithm_used| equals 0, the analytical version of DMC algorithm will be used, otherwise a numeric version will be executed. It is also clearly visible, that those algorithms have new, distinct names. These should be used consequently in both C and MATLAB code. All will be properly set further in this document. First, the software initialization function (named \lstinline[style=myc]|controller_setup|) has to be modified, by substituting a line:
\begin{lstlisting}[style=myc]
    controller(NULL,NULL);
\end{lstlisting}
with two new lines:
\begin{lstlisting}[style=myc]
    controllerDMCA(NULL,NULL);
    controllerDMCN(NULL,NULL);
\end{lstlisting}
Lastly, the value of variable \lstinline[style=myc]|algorithm_used| has to be defined in time. Therefore, in the function \lstinline[style=myc]|loop()|, right before the newly added conditional execution of control algorithms, a following code should be added:
\begin{lstlisting}[style=myc]
if(i == 0 && algorithm_used == 0) algorithm_used == 1;
if(i == 0 && algorithm_used == 1) algorithm_used == 0;
\end{lstlisting}
which will cause the algorithm to change each time a variable \lstinline[style=myc]|i| is zeroed, which occurs each 100 iterations.

Having the C part upgraded, next, the MATLAB script has to be modified. Firstly, the line:
\begin{lstlisting}[style=mym]
AutoMATiC_Generate('AutoMATiC_DMC_Numeric_Algorithm','controller');
\end{lstlisting}
has to be changed to:
\begin{lstlisting}[style=mym]
AutoMATiC_Generate('AutoMATiC_DMC_Numeric_Algorithm','controllerDMCN',1);
\end{lstlisting}
and a following code has to be appended to this script:
\begin{lstlisting}[style=mym]
lambda= [0.1 0.1]; % Penalty--control signals' increments
dumin =-[.1  .1 ]; % Lower bound--control increments
dumax = [.1  .1 ]; % Upper bound--control increments
code = AutoMATiC_Generate('AutoMATiC_DMC_Analytic_Algorithm','controllerDMCA',0);
\end{lstlisting}
which will generate second definition of an algorithm, with lower penalty for control signals' increments, and also more relaxed constraints on control increments rendering this particular implementation a bit more aggressive. By adding third argument to the execution of the \lstinline[style=mym]|AutoMATiC_Generate| function, the transcompiler is informed that the generated algorithm is not yet the last one in the project (value of 1), or that it is indeed the last one that will be generated (value of 0). This script finally completes the generation of multiple algorithms in the same project, where a simple condition is used to switch between those two.

\section{Extending of the Library}
\subsection{Proportional-Integral-Derivative Controller}


\appendix
\section{Analytic DMC -- generated source of \texttt{main\_mpc.c}}\label{ch:dmca}
\begin{lstlisting}[style=myc]
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\defines.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\profiler.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\mpctools.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\simulated_signals.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\obl_macierzowe.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\mat_lib.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\alokacja_nr.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\pk.h"
#include "stm32f7xx_hal.h"
#include <string.h>
#include "main.h"
#include "mat_lib.h"

ArchiveData ad;
CurrentControl cc;

long get_time(){ return HAL_GetTick(); }

extern void timer_loop(void);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
    if (htim->Instance == TIM2) {
        timer_loop();
    }
}
void measurements(){
profiler_start(4);
    new_output(&ad,__measureOutput());
profiler_end(4);
}
void controls(){
profiler_start(3);
    __setControlValue(last_control(&ad));
profiler_end(3);
}
void hardware_setup(){
profiler_start(1);
    low_lvl_main();
profiler_end(1);
}

void controller(ArchiveData * ad, CurrentControl * c){
	static float** AutoMATiC_DMC_Y;
	static float** AutoMATiC_DMC_Yzad;
	static float** AutoMATiC_DMC_dUp;
	static float** AutoMATiC_DMC_du;
	static float** AutoMATiC_DMC_dutmp1;
	static float** AutoMATiC_DMC_dutmp2;
	static float** AutoMATiC_DMC_e;
	static long AutoMATiC_DMC_i;
	static long AutoMATiC_DMC_itmp;
	static long AutoMATiC_DMC_j;
	static long AutoMATiC_DMC_n;
	static float** AutoMATiC_DMC_tmpu;
	static float** control_value;
	static long j;
	static long k;
	static float** AutoMATiC_DMC_Ke;
	static float** AutoMATiC_DMC_Ku;
	static float** dumax;
	static float** dumin;
	static float** umax;
	static float** umin;
	if(ad == NULL){
		AutoMATiC_DMC_dUp = dtablica(1,10,1,1);
		AutoMATiC_DMC_Yzad = dtablica(1,10,1,1);
		AutoMATiC_DMC_Y = dtablica(1,10,1,1);
		AutoMATiC_DMC_tmpu = dtablica(1,2,1,1);
		AutoMATiC_DMC_e = dtablica(1,2,1,1);
		control_value = dtablica(1,1,1,2);
		AutoMATiC_DMC_dutmp1 = dtablica(1,2,1,1);
		AutoMATiC_DMC_Ke = dtablica(1,2,1,2);
		AutoMATiC_DMC_Ke[1][1] = 3.373006e-01f;
		AutoMATiC_DMC_Ke[1][2] = -8.539666e-02f;
		AutoMATiC_DMC_Ke[2][1] = -1.016548e-01f;
		AutoMATiC_DMC_Ke[2][2] = 5.115693e-01f;
		AutoMATiC_DMC_dutmp2 = dtablica(1,2,1,1);
		AutoMATiC_DMC_Ku = dtablica(1,2,1,10);
		AutoMATiC_DMC_Ku[1][1] = 1.246174e+00f;
		AutoMATiC_DMC_Ku[1][2] = 1.325670e-01f;
		AutoMATiC_DMC_Ku[1][3] = 6.357246e-01f;
		AutoMATiC_DMC_Ku[1][4] = 6.227585e-02f;
		AutoMATiC_DMC_Ku[1][5] = 3.156590e-01f;
		AutoMATiC_DMC_Ku[1][6] = 2.680473e-02f;
		AutoMATiC_DMC_Ku[1][7] = 1.498871e-01f;
		AutoMATiC_DMC_Ku[1][8] = 1.083353e-02f;
		AutoMATiC_DMC_Ku[1][9] = 4.935498e-02f;
		AutoMATiC_DMC_Ku[1][10] = 3.084074e-03f;
		AutoMATiC_DMC_Ku[2][1] = 5.999027e-02f;
		AutoMATiC_DMC_Ku[2][2] = 8.674656e-01f;
		AutoMATiC_DMC_Ku[2][3] = -1.205763e-01f;
		AutoMATiC_DMC_Ku[2][4] = 2.407995e-01f;
		AutoMATiC_DMC_Ku[2][5] = -8.573715e-02f;
		AutoMATiC_DMC_Ku[2][6] = 6.612598e-02f;
		AutoMATiC_DMC_Ku[2][7] = -4.201587e-02f;
		AutoMATiC_DMC_Ku[2][8] = 1.771064e-02f;
		AutoMATiC_DMC_Ku[2][9] = -1.437298e-02f;
		AutoMATiC_DMC_Ku[2][10] = 3.741803e-03f;
		AutoMATiC_DMC_du = dtablica(1,2,1,1);
		dumax = dtablica(1,1,1,2);
		dumax[1][1] = 1.000000e-02f;
		dumax[1][2] = 1.000000e-02f;
		dumin = dtablica(1,1,1,2);
		dumin[1][1] = -1.000000e-02f;
		dumin[1][2] = -1.000000e-02f;
		umax = dtablica(1,1,1,2);
		umax[1][1] = 1.000000e+00f;
		umax[1][2] = 1.000000e+00f;
		umin = dtablica(1,1,1,2);
		umin[1][1] = -1.000000e+00f;
		umin[1][2] = -1.000000e+00f;
		return;
	}
	for(j=1;j<=10;++j) for(k=1;k<=1;++k) AutoMATiC_DMC_dUp[j][k] = 0;
	for(j=1;j<=10;++j) for(k=1;k<=1;++k) AutoMATiC_DMC_Yzad[j][k] = 0;
	for(j=1;j<=10;++j) for(k=1;k<=1;++k) AutoMATiC_DMC_Y[j][k] = 0;
	for(j=1;j<=2;++j) for(k=1;k<=1;++k) AutoMATiC_DMC_tmpu[j][k] = 0;
	AutoMATiC_DMC_itmp=1;
	for(AutoMATiC_DMC_i=1;AutoMATiC_DMC_i<=5;++AutoMATiC_DMC_i){
		for(AutoMATiC_DMC_j=1;AutoMATiC_DMC_j<=2;++AutoMATiC_DMC_j){
			AutoMATiC_DMC_dUp[AutoMATiC_DMC_itmp][1]=ad->du[ad->k-AutoMATiC_DMC_i][AutoMATiC_DMC_j-1];
			AutoMATiC_DMC_itmp=AutoMATiC_DMC_itmp+1;
		}
	}
	AutoMATiC_DMC_itmp=1;
	for(AutoMATiC_DMC_i=1;AutoMATiC_DMC_i<=5;++AutoMATiC_DMC_i){
		for(AutoMATiC_DMC_j=1;AutoMATiC_DMC_j<=2;++AutoMATiC_DMC_j){
			AutoMATiC_DMC_Yzad[AutoMATiC_DMC_itmp][1]=ad->z[AutoMATiC_DMC_j-1];
			AutoMATiC_DMC_itmp=AutoMATiC_DMC_itmp+1;
		}
	}
	AutoMATiC_DMC_itmp=1;
	for(AutoMATiC_DMC_i=1;AutoMATiC_DMC_i<=5;++AutoMATiC_DMC_i){
		for(AutoMATiC_DMC_j=1;AutoMATiC_DMC_j<=2;++AutoMATiC_DMC_j){
			AutoMATiC_DMC_Y[AutoMATiC_DMC_itmp][1]=ad->y[ad->k][AutoMATiC_DMC_j-1];
			AutoMATiC_DMC_itmp=AutoMATiC_DMC_itmp+1;
		}
	}
	for(j=1;j<=2;++j) for(k=1;k<=1;++k) AutoMATiC_DMC_e[j][k] = 0;
	for(AutoMATiC_DMC_i=1;AutoMATiC_DMC_i<=2;++AutoMATiC_DMC_i){
		AutoMATiC_DMC_e[AutoMATiC_DMC_i][1]=ad->z[AutoMATiC_DMC_i-1]-ad->y[ad->k][AutoMATiC_DMC_i-1];
	}
	iloczynab(AutoMATiC_DMC_Ke,AutoMATiC_DMC_e,AutoMATiC_DMC_dutmp1,2,2,2,1);
	iloczynab(AutoMATiC_DMC_Ku,AutoMATiC_DMC_dUp,AutoMATiC_DMC_dutmp2,2,10,10,1);
	sumaaa(AutoMATiC_DMC_dutmp1,AutoMATiC_DMC_dutmp2,AutoMATiC_DMC_du,2,1,-1);
	for(AutoMATiC_DMC_n=1;AutoMATiC_DMC_n<=2;++AutoMATiC_DMC_n){
		if(AutoMATiC_DMC_du[AutoMATiC_DMC_n][1]>dumax[1][AutoMATiC_DMC_n]){
			AutoMATiC_DMC_du[AutoMATiC_DMC_n][1]=dumax[1][AutoMATiC_DMC_n];
		}
		if(AutoMATiC_DMC_du[AutoMATiC_DMC_n][1]<dumin[1][AutoMATiC_DMC_n]){
			AutoMATiC_DMC_du[AutoMATiC_DMC_n][1]=dumin[1][AutoMATiC_DMC_n];
		}
		AutoMATiC_DMC_tmpu[AutoMATiC_DMC_n][1]=ad->u[ad->k-1][AutoMATiC_DMC_n-1]+AutoMATiC_DMC_du[AutoMATiC_DMC_n][1];
		if(AutoMATiC_DMC_tmpu[AutoMATiC_DMC_n][1]>umax[1][AutoMATiC_DMC_n]){
			AutoMATiC_DMC_tmpu[AutoMATiC_DMC_n][1]=umax[1][AutoMATiC_DMC_n];
		}
		if(AutoMATiC_DMC_tmpu[AutoMATiC_DMC_n][1]<umin[1][AutoMATiC_DMC_n]){
			AutoMATiC_DMC_tmpu[AutoMATiC_DMC_n][1]=umin[1][AutoMATiC_DMC_n];
		}
		AutoMATiC_DMC_du[AutoMATiC_DMC_n][1]=AutoMATiC_DMC_tmpu[AutoMATiC_DMC_n][1]-ad->u[ad->k-1][AutoMATiC_DMC_n-1];
	}
	for(j=1;j<=1;++j) for(k=1;k<=2;++k) control_value[j][k] = 0;
	for(AutoMATiC_DMC_n=1;AutoMATiC_DMC_n<=2;++AutoMATiC_DMC_n){
		control_value[1][AutoMATiC_DMC_n]=AutoMATiC_DMC_du[AutoMATiC_DMC_n][1];
	}

	set_current_control_increment(c,&(control_value[1][1])); // du is indexed starting with 1, therefore to maintain compatibility it is required to refer to first element of an actual array
}

void controller_setup(){
profiler_start(2);
    init_archive_data(&ad, 200, 200, 2, 2, 0, 0, 0.01);
    init_current_control(&cc,&ad);
    controller(NULL,NULL);
profiler_end(2);
}

void idle(){
profiler_start(13);
    const int k = 0;
	static char str[1000] = {0};

    sprintf(str, "x = [%f,%f,",ad.y[k][0], ad.y[k][1]);    write_string(str);
    sprintf(str,      "%f,%f,",ad.z[0], ad.z[1]);          write_string(str);
    sprintf(str,      "%f,%f,",ad.u[k-1][0],ad.u[k-1][1]); write_string(str);
    write_string("];\n\r");
profiler_end(13);
}

void loop(){
profiler_start(10);
    static int i = 0;
	if(i<  50){ ad.z[0] = -0.1; ad.z[1] =  0.2; }
	else      { ad.z[0] =  0.1; ad.z[1] = -0.2; }
    if(++i > 100) i = 0;
	
profiler_start(50);
	controller(&ad,&cc);
profiler_end(50);
	
    push_current_controls_to_archive_data(&cc,&ad);	
profiler_end(10);
}

void timeout(){
    while(1);
}
\end{lstlisting}

\section{Numeric DMC -- generated source of \texttt{main\_mpc.c}}\label{ch:dmcn}
\begin{lstlisting}[style=myc]
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\defines.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\profiler.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\mpctools.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\simulated_signals.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\obl_macierzowe.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\mat_lib.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\alokacja_nr.h"
#include "C:\Users\Admin\Documents\GitHub\AutoMATiC\Libs\C\pk.h"
#include "stm32f7xx_hal.h"
#include <string.h>
#include "main.h"
#include "mat_lib.h"

ArchiveData ad;
CurrentControl cc;

long get_time(){ return HAL_GetTick(); }

extern void timer_loop(void);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
    if (htim->Instance == TIM2) {
        timer_loop();
    }
}
void measurements(){
profiler_start(4);
    new_output(&ad,__measureOutput());
profiler_end(4);
}
void controls(){
profiler_start(3);
    __setControlValue(last_control(&ad));
profiler_end(3);
}
void hardware_setup(){
profiler_start(1);
    low_lvl_main();
profiler_end(1);
}

void controller(ArchiveData * ad, CurrentControl * c){
	static float** AutoMATiC_DMC_Y;
	static float** AutoMATiC_DMC_Yzad;
	static float** AutoMATiC_DMC_btmp1;
	static float** AutoMATiC_DMC_btmp2;
	static float** AutoMATiC_DMC_dUp;
	static float** AutoMATiC_DMC_du;
	static float** AutoMATiC_DMC_dutmp1;
	static float** AutoMATiC_DMC_dutmp2;
	static float** AutoMATiC_DMC_e;
	static float** AutoMATiC_DMC_ftmp1;
	static float** AutoMATiC_DMC_ftmp2;
	static float** AutoMATiC_DMC_ftmp3;
	static float** AutoMATiC_DMC_ftmp4;
	static long AutoMATiC_DMC_i;
	static long AutoMATiC_DMC_itmp;
	static long AutoMATiC_DMC_j;
	static long AutoMATiC_DMC_n;
	static float** AutoMATiC_DMC_tmpu;
	static float** AutoMATiC_DMC_uk;
	static float** control_value;
	static long j;
	static long k;
	static float** AutoMATiC_DMC_Ke;
	static float** AutoMATiC_DMC_Ku;
	static float** AutoMATiC_DMC_Mp;
	static float** AutoMATiC_DMC_fconst;
	static float** AutoMATiC_DMC_bvar;
	static float** AutoMATiC_DMC_b;
	static float** dumax;
	static float** dumin;
	static float** umax;
	static float** umin;
	static float ** AutoMATiC_DMC_H;
	static float ** AutoMATiC_DMC_A;
	static float * AutoMATiC_DMC_ftmp;
	static float * AutoMATiC_DMC_btmp;
	static float * AutoMATiC_DMC_qpx;
	if(ad == NULL){
		ustawilogr(40);
		ustawilzm(10);
		inicjalizacjapk();
		AutoMATiC_DMC_A=pobierzA();
		AutoMATiC_DMC_H=pobierzG();
		AutoMATiC_DMC_btmp=pobierzb();
		AutoMATiC_DMC_ftmp=pobierzt();
		AutoMATiC_DMC_qpx=pobierzx();
		AutoMATiC_DMC_A[1][1] = 1.000000e+00f;
		AutoMATiC_DMC_A[1][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[1][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[1][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[1][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[1][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[1][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[1][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[1][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[1][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[2][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[2][2] = 1.000000e+00f;
		AutoMATiC_DMC_A[2][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[2][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[2][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[2][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[2][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[2][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[2][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[2][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[3][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[3][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[3][3] = 1.000000e+00f;
		AutoMATiC_DMC_A[3][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[3][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[3][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[3][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[3][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[3][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[3][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[4][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[4][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[4][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[4][4] = 1.000000e+00f;
		AutoMATiC_DMC_A[4][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[4][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[4][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[4][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[4][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[4][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[5][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[5][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[5][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[5][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[5][5] = 1.000000e+00f;
		AutoMATiC_DMC_A[5][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[5][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[5][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[5][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[5][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[6][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[6][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[6][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[6][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[6][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[6][6] = 1.000000e+00f;
		AutoMATiC_DMC_A[6][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[6][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[6][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[6][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[7][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[7][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[7][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[7][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[7][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[7][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[7][7] = 1.000000e+00f;
		AutoMATiC_DMC_A[7][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[7][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[7][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[8][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[8][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[8][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[8][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[8][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[8][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[8][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[8][8] = 1.000000e+00f;
		AutoMATiC_DMC_A[8][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[8][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[9][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[9][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[9][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[9][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[9][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[9][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[9][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[9][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[9][9] = 1.000000e+00f;
		AutoMATiC_DMC_A[9][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[10][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[10][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[10][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[10][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[10][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[10][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[10][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[10][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[10][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[10][10] = 1.000000e+00f;
		AutoMATiC_DMC_A[11][1] = -1.000000e+00f;
		AutoMATiC_DMC_A[11][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[11][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[11][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[11][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[11][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[11][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[11][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[11][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[11][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[12][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[12][2] = -1.000000e+00f;
		AutoMATiC_DMC_A[12][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[12][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[12][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[12][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[12][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[12][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[12][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[12][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[13][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[13][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[13][3] = -1.000000e+00f;
		AutoMATiC_DMC_A[13][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[13][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[13][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[13][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[13][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[13][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[13][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[14][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[14][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[14][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[14][4] = -1.000000e+00f;
		AutoMATiC_DMC_A[14][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[14][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[14][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[14][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[14][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[14][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[15][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[15][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[15][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[15][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[15][5] = -1.000000e+00f;
		AutoMATiC_DMC_A[15][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[15][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[15][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[15][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[15][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[16][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[16][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[16][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[16][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[16][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[16][6] = -1.000000e+00f;
		AutoMATiC_DMC_A[16][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[16][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[16][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[16][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[17][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[17][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[17][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[17][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[17][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[17][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[17][7] = -1.000000e+00f;
		AutoMATiC_DMC_A[17][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[17][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[17][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[18][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[18][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[18][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[18][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[18][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[18][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[18][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[18][8] = -1.000000e+00f;
		AutoMATiC_DMC_A[18][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[18][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[19][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[19][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[19][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[19][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[19][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[19][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[19][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[19][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[19][9] = -1.000000e+00f;
		AutoMATiC_DMC_A[19][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[20][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[20][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[20][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[20][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[20][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[20][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[20][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[20][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[20][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[20][10] = -1.000000e+00f;
		AutoMATiC_DMC_A[21][1] = 1.000000e+00f;
		AutoMATiC_DMC_A[21][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[21][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[21][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[21][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[21][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[21][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[21][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[21][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[21][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[22][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[22][2] = 1.000000e+00f;
		AutoMATiC_DMC_A[22][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[22][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[22][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[22][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[22][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[22][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[22][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[22][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[23][1] = 1.000000e+00f;
		AutoMATiC_DMC_A[23][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[23][3] = 1.000000e+00f;
		AutoMATiC_DMC_A[23][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[23][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[23][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[23][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[23][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[23][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[23][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[24][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[24][2] = 1.000000e+00f;
		AutoMATiC_DMC_A[24][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[24][4] = 1.000000e+00f;
		AutoMATiC_DMC_A[24][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[24][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[24][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[24][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[24][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[24][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[25][1] = 1.000000e+00f;
		AutoMATiC_DMC_A[25][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[25][3] = 1.000000e+00f;
		AutoMATiC_DMC_A[25][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[25][5] = 1.000000e+00f;
		AutoMATiC_DMC_A[25][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[25][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[25][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[25][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[25][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[26][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[26][2] = 1.000000e+00f;
		AutoMATiC_DMC_A[26][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[26][4] = 1.000000e+00f;
		AutoMATiC_DMC_A[26][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[26][6] = 1.000000e+00f;
		AutoMATiC_DMC_A[26][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[26][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[26][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[26][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[27][1] = 1.000000e+00f;
		AutoMATiC_DMC_A[27][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[27][3] = 1.000000e+00f;
		AutoMATiC_DMC_A[27][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[27][5] = 1.000000e+00f;
		AutoMATiC_DMC_A[27][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[27][7] = 1.000000e+00f;
		AutoMATiC_DMC_A[27][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[27][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[27][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[28][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[28][2] = 1.000000e+00f;
		AutoMATiC_DMC_A[28][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[28][4] = 1.000000e+00f;
		AutoMATiC_DMC_A[28][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[28][6] = 1.000000e+00f;
		AutoMATiC_DMC_A[28][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[28][8] = 1.000000e+00f;
		AutoMATiC_DMC_A[28][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[28][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[29][1] = 1.000000e+00f;
		AutoMATiC_DMC_A[29][2] = 0.000000e+00f;
		AutoMATiC_DMC_A[29][3] = 1.000000e+00f;
		AutoMATiC_DMC_A[29][4] = 0.000000e+00f;
		AutoMATiC_DMC_A[29][5] = 1.000000e+00f;
		AutoMATiC_DMC_A[29][6] = 0.000000e+00f;
		AutoMATiC_DMC_A[29][7] = 1.000000e+00f;
		AutoMATiC_DMC_A[29][8] = 0.000000e+00f;
		AutoMATiC_DMC_A[29][9] = 1.000000e+00f;
		AutoMATiC_DMC_A[29][10] = 0.000000e+00f;
		AutoMATiC_DMC_A[30][1] = 0.000000e+00f;
		AutoMATiC_DMC_A[30][2] = 1.000000e+00f;
		AutoMATiC_DMC_A[30][3] = 0.000000e+00f;
		AutoMATiC_DMC_A[30][4] = 1.000000e+00f;
		AutoMATiC_DMC_A[30][5] = 0.000000e+00f;
		AutoMATiC_DMC_A[30][6] = 1.000000e+00f;
		AutoMATiC_DMC_A[30][7] = 0.000000e+00f;
		AutoMATiC_DMC_A[30][8] = 1.000000e+00f;
		AutoMATiC_DMC_A[30][9] = 0.000000e+00f;
		AutoMATiC_DMC_A[30][10] = 1.000000e+00f;
		AutoMATiC_DMC_A[31][1] = -1.000000e+00f;
		AutoMATiC_DMC_A[31][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[31][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[31][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[31][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[31][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[31][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[31][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[31][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[31][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[32][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[32][2] = -1.000000e+00f;
		AutoMATiC_DMC_A[32][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[32][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[32][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[32][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[32][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[32][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[32][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[32][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[33][1] = -1.000000e+00f;
		AutoMATiC_DMC_A[33][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[33][3] = -1.000000e+00f;
		AutoMATiC_DMC_A[33][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[33][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[33][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[33][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[33][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[33][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[33][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[34][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[34][2] = -1.000000e+00f;
		AutoMATiC_DMC_A[34][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[34][4] = -1.000000e+00f;
		AutoMATiC_DMC_A[34][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[34][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[34][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[34][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[34][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[34][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[35][1] = -1.000000e+00f;
		AutoMATiC_DMC_A[35][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[35][3] = -1.000000e+00f;
		AutoMATiC_DMC_A[35][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[35][5] = -1.000000e+00f;
		AutoMATiC_DMC_A[35][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[35][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[35][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[35][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[35][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[36][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[36][2] = -1.000000e+00f;
		AutoMATiC_DMC_A[36][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[36][4] = -1.000000e+00f;
		AutoMATiC_DMC_A[36][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[36][6] = -1.000000e+00f;
		AutoMATiC_DMC_A[36][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[36][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[36][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[36][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[37][1] = -1.000000e+00f;
		AutoMATiC_DMC_A[37][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[37][3] = -1.000000e+00f;
		AutoMATiC_DMC_A[37][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[37][5] = -1.000000e+00f;
		AutoMATiC_DMC_A[37][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[37][7] = -1.000000e+00f;
		AutoMATiC_DMC_A[37][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[37][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[37][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[38][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[38][2] = -1.000000e+00f;
		AutoMATiC_DMC_A[38][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[38][4] = -1.000000e+00f;
		AutoMATiC_DMC_A[38][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[38][6] = -1.000000e+00f;
		AutoMATiC_DMC_A[38][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[38][8] = -1.000000e+00f;
		AutoMATiC_DMC_A[38][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[38][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[39][1] = -1.000000e+00f;
		AutoMATiC_DMC_A[39][2] = -0.000000e+00f;
		AutoMATiC_DMC_A[39][3] = -1.000000e+00f;
		AutoMATiC_DMC_A[39][4] = -0.000000e+00f;
		AutoMATiC_DMC_A[39][5] = -1.000000e+00f;
		AutoMATiC_DMC_A[39][6] = -0.000000e+00f;
		AutoMATiC_DMC_A[39][7] = -1.000000e+00f;
		AutoMATiC_DMC_A[39][8] = -0.000000e+00f;
		AutoMATiC_DMC_A[39][9] = -1.000000e+00f;
		AutoMATiC_DMC_A[39][10] = -0.000000e+00f;
		AutoMATiC_DMC_A[40][1] = -0.000000e+00f;
		AutoMATiC_DMC_A[40][2] = -1.000000e+00f;
		AutoMATiC_DMC_A[40][3] = -0.000000e+00f;
		AutoMATiC_DMC_A[40][4] = -1.000000e+00f;
		AutoMATiC_DMC_A[40][5] = -0.000000e+00f;
		AutoMATiC_DMC_A[40][6] = -1.000000e+00f;
		AutoMATiC_DMC_A[40][7] = -0.000000e+00f;
		AutoMATiC_DMC_A[40][8] = -1.000000e+00f;
		AutoMATiC_DMC_A[40][9] = -0.000000e+00f;
		AutoMATiC_DMC_A[40][10] = -1.000000e+00f;
		AutoMATiC_DMC_H[1][1] = 1.344566e+02f;
		AutoMATiC_DMC_H[1][2] = 4.114478e+01f;
		AutoMATiC_DMC_H[1][3] = 1.000269e+02f;
		AutoMATiC_DMC_H[1][4] = 3.169500e+01f;
		AutoMATiC_DMC_H[1][5] = 6.190011e+01f;
		AutoMATiC_DMC_H[1][6] = 2.023139e+01f;
		AutoMATiC_DMC_H[1][7] = 2.567725e+01f;
		AutoMATiC_DMC_H[1][8] = 8.808511e+00f;
		AutoMATiC_DMC_H[1][9] = 0.000000e+00f;
		AutoMATiC_DMC_H[1][10] = 0.000000e+00f;
		AutoMATiC_DMC_H[2][1] = 4.114478e+01f;
		AutoMATiC_DMC_H[2][2] = 3.436150e+01f;
		AutoMATiC_DMC_H[2][3] = 3.099487e+01f;
		AutoMATiC_DMC_H[2][4] = 2.477126e+01f;
		AutoMATiC_DMC_H[2][5] = 1.931418e+01f;
		AutoMATiC_DMC_H[2][6] = 1.576652e+01f;
		AutoMATiC_DMC_H[2][7] = 8.233726e+00f;
		AutoMATiC_DMC_H[2][8] = 6.910587e+00f;
		AutoMATiC_DMC_H[2][9] = 0.000000e+00f;
		AutoMATiC_DMC_H[2][10] = 0.000000e+00f;
		AutoMATiC_DMC_H[3][1] = 1.000269e+02f;
		AutoMATiC_DMC_H[3][2] = 3.099487e+01f;
		AutoMATiC_DMC_H[3][3] = 8.804002e+01f;
		AutoMATiC_DMC_H[3][4] = 2.792375e+01f;
		AutoMATiC_DMC_H[3][5] = 5.644363e+01f;
		AutoMATiC_DMC_H[3][6] = 1.883764e+01f;
		AutoMATiC_DMC_H[3][7] = 2.413991e+01f;
		AutoMATiC_DMC_H[3][8] = 8.414358e+00f;
		AutoMATiC_DMC_H[3][9] = 0.000000e+00f;
		AutoMATiC_DMC_H[3][10] = 0.000000e+00f;
		AutoMATiC_DMC_H[4][1] = 3.169500e+01f;
		AutoMATiC_DMC_H[4][2] = 2.477126e+01f;
		AutoMATiC_DMC_H[4][3] = 2.792375e+01f;
		AutoMATiC_DMC_H[4][4] = 2.454154e+01f;
		AutoMATiC_DMC_H[4][5] = 1.838345e+01f;
		AutoMATiC_DMC_H[4][6] = 1.514642e+01f;
		AutoMATiC_DMC_H[4][7] = 8.018635e+00f;
		AutoMATiC_DMC_H[4][8] = 6.775021e+00f;
		AutoMATiC_DMC_H[4][9] = 0.000000e+00f;
		AutoMATiC_DMC_H[4][10] = 0.000000e+00f;
		AutoMATiC_DMC_H[5][1] = 6.190011e+01f;
		AutoMATiC_DMC_H[5][2] = 1.931418e+01f;
		AutoMATiC_DMC_H[5][3] = 5.644363e+01f;
		AutoMATiC_DMC_H[5][4] = 1.838345e+01f;
		AutoMATiC_DMC_H[5][5] = 4.711061e+01f;
		AutoMATiC_DMC_H[5][6] = 1.565679e+01f;
		AutoMATiC_DMC_H[5][7] = 2.097070e+01f;
		AutoMATiC_DMC_H[5][8] = 7.558490e+00f;
		AutoMATiC_DMC_H[5][9] = 0.000000e+00f;
		AutoMATiC_DMC_H[5][10] = 0.000000e+00f;
		AutoMATiC_DMC_H[6][1] = 2.023139e+01f;
		AutoMATiC_DMC_H[6][2] = 1.576652e+01f;
		AutoMATiC_DMC_H[6][3] = 1.883764e+01f;
		AutoMATiC_DMC_H[6][4] = 1.514642e+01f;
		AutoMATiC_DMC_H[6][5] = 1.565679e+01f;
		AutoMATiC_DMC_H[6][6] = 1.510759e+01f;
		AutoMATiC_DMC_H[6][7] = 7.391926e+00f;
		AutoMATiC_DMC_H[6][8] = 6.332568e+00f;
		AutoMATiC_DMC_H[6][9] = 0.000000e+00f;
		AutoMATiC_DMC_H[6][10] = 0.000000e+00f;
		AutoMATiC_DMC_H[7][1] = 2.567725e+01f;
		AutoMATiC_DMC_H[7][2] = 8.233726e+00f;
		AutoMATiC_DMC_H[7][3] = 2.413991e+01f;
		AutoMATiC_DMC_H[7][4] = 8.018635e+00f;
		AutoMATiC_DMC_H[7][5] = 2.097070e+01f;
		AutoMATiC_DMC_H[7][6] = 7.391926e+00f;
		AutoMATiC_DMC_H[7][7] = 1.634423e+01f;
		AutoMATiC_DMC_H[7][8] = 5.541646e+00f;
		AutoMATiC_DMC_H[7][9] = 0.000000e+00f;
		AutoMATiC_DMC_H[7][10] = 0.000000e+00f;
		AutoMATiC_DMC_H[8][1] = 8.808511e+00f;
		AutoMATiC_DMC_H[8][2] = 6.910587e+00f;
		AutoMATiC_DMC_H[8][3] = 8.414358e+00f;
		AutoMATiC_DMC_H[8][4] = 6.775021e+00f;
		AutoMATiC_DMC_H[8][5] = 7.558490e+00f;
		AutoMATiC_DMC_H[8][6] = 6.332568e+00f;
		AutoMATiC_DMC_H[8][7] = 5.541646e+00f;
		AutoMATiC_DMC_H[8][8] = 6.871756e+00f;
		AutoMATiC_DMC_H[8][9] = 0.000000e+00f;
		AutoMATiC_DMC_H[8][10] = 0.000000e+00f;
		AutoMATiC_DMC_H[9][1] = 0.000000e+00f;
		AutoMATiC_DMC_H[9][2] = 0.000000e+00f;
		AutoMATiC_DMC_H[9][3] = 0.000000e+00f;
		AutoMATiC_DMC_H[9][4] = 0.000000e+00f;
		AutoMATiC_DMC_H[9][5] = 0.000000e+00f;
		AutoMATiC_DMC_H[9][6] = 0.000000e+00f;
		AutoMATiC_DMC_H[9][7] = 0.000000e+00f;
		AutoMATiC_DMC_H[9][8] = 0.000000e+00f;
		AutoMATiC_DMC_H[9][9] = 2.000000e+00f;
		AutoMATiC_DMC_H[9][10] = 0.000000e+00f;
		AutoMATiC_DMC_H[10][1] = 0.000000e+00f;
		AutoMATiC_DMC_H[10][2] = 0.000000e+00f;
		AutoMATiC_DMC_H[10][3] = 0.000000e+00f;
		AutoMATiC_DMC_H[10][4] = 0.000000e+00f;
		AutoMATiC_DMC_H[10][5] = 0.000000e+00f;
		AutoMATiC_DMC_H[10][6] = 0.000000e+00f;
		AutoMATiC_DMC_H[10][7] = 0.000000e+00f;
		AutoMATiC_DMC_H[10][8] = 0.000000e+00f;
		AutoMATiC_DMC_H[10][9] = 0.000000e+00f;
		AutoMATiC_DMC_H[10][10] = 2.000000e+00f;
		AutoMATiC_DMC_dUp = dtablica(1,10,1,1);
		AutoMATiC_DMC_Yzad = dtablica(1,10,1,1);
		AutoMATiC_DMC_Y = dtablica(1,10,1,1);
		AutoMATiC_DMC_tmpu = dtablica(1,2,1,1);
		AutoMATiC_DMC_e = dtablica(1,2,1,1);
		AutoMATiC_DMC_du = dtablica(1,2,1,1);
		AutoMATiC_DMC_uk = dtablica(1,2,1,1);
		control_value = dtablica(1,1,1,2);
		AutoMATiC_DMC_dutmp1 = dtablica(1,2,1,1);
		AutoMATiC_DMC_Ke = dtablica(1,2,1,2);
		AutoMATiC_DMC_Ke[1][1] = 3.373006e-01f;
		AutoMATiC_DMC_Ke[1][2] = -8.539666e-02f;
		AutoMATiC_DMC_Ke[2][1] = -1.016548e-01f;
		AutoMATiC_DMC_Ke[2][2] = 5.115693e-01f;
		AutoMATiC_DMC_dutmp2 = dtablica(1,2,1,1);
		AutoMATiC_DMC_Ku = dtablica(1,2,1,10);
		AutoMATiC_DMC_Ku[1][1] = 1.246174e+00f;
		AutoMATiC_DMC_Ku[1][2] = 1.325670e-01f;
		AutoMATiC_DMC_Ku[1][3] = 6.357246e-01f;
		AutoMATiC_DMC_Ku[1][4] = 6.227585e-02f;
		AutoMATiC_DMC_Ku[1][5] = 3.156590e-01f;
		AutoMATiC_DMC_Ku[1][6] = 2.680473e-02f;
		AutoMATiC_DMC_Ku[1][7] = 1.498871e-01f;
		AutoMATiC_DMC_Ku[1][8] = 1.083353e-02f;
		AutoMATiC_DMC_Ku[1][9] = 4.935498e-02f;
		AutoMATiC_DMC_Ku[1][10] = 3.084074e-03f;
		AutoMATiC_DMC_Ku[2][1] = 5.999027e-02f;
		AutoMATiC_DMC_Ku[2][2] = 8.674656e-01f;
		AutoMATiC_DMC_Ku[2][3] = -1.205763e-01f;
		AutoMATiC_DMC_Ku[2][4] = 2.407995e-01f;
		AutoMATiC_DMC_Ku[2][5] = -8.573715e-02f;
		AutoMATiC_DMC_Ku[2][6] = 6.612598e-02f;
		AutoMATiC_DMC_Ku[2][7] = -4.201587e-02f;
		AutoMATiC_DMC_Ku[2][8] = 1.771064e-02f;
		AutoMATiC_DMC_Ku[2][9] = -1.437298e-02f;
		AutoMATiC_DMC_Ku[2][10] = 3.741803e-03f;
		AutoMATiC_DMC_ftmp1 = dtablica(1,10,1,1);
		AutoMATiC_DMC_ftmp2 = dtablica(1,10,1,1);
		AutoMATiC_DMC_Mp = dtablica(1,10,1,10);
		AutoMATiC_DMC_Mp[1][1] = 2.552292e+00f;
		AutoMATiC_DMC_Mp[1][2] = 6.321206e-01f;
		AutoMATiC_DMC_Mp[1][3] = 1.249453e+00f;
		AutoMATiC_DMC_Mp[1][4] = 2.325442e-01f;
		AutoMATiC_DMC_Mp[1][5] = 6.116594e-01f;
		AutoMATiC_DMC_Mp[1][6] = 8.554821e-02f;
		AutoMATiC_DMC_Mp[1][7] = 2.994327e-01f;
		AutoMATiC_DMC_Mp[1][8] = 3.147143e-02f;
		AutoMATiC_DMC_Mp[1][9] = 1.465848e-01f;
		AutoMATiC_DMC_Mp[1][10] = 1.157769e-02f;
		AutoMATiC_DMC_Mp[2][1] = 8.111244e-01f;
		AutoMATiC_DMC_Mp[2][2] = 1.426990e+00f;
		AutoMATiC_DMC_Mp[2][3] = 1.532016e-01f;
		AutoMATiC_DMC_Mp[2][4] = 4.088396e-01f;
		AutoMATiC_DMC_Mp[2][5] = 2.893605e-02f;
		AutoMATiC_DMC_Mp[2][6] = 1.171345e-01f;
		AutoMATiC_DMC_Mp[2][7] = 5.465313e-03f;
		AutoMATiC_DMC_Mp[2][8] = 3.355960e-02f;
		AutoMATiC_DMC_Mp[2][9] = 1.032264e-03f;
		AutoMATiC_DMC_Mp[2][10] = 9.614986e-03f;
		AutoMATiC_DMC_Mp[3][1] = 3.801745e+00f;
		AutoMATiC_DMC_Mp[3][2] = 8.646647e-01f;
		AutoMATiC_DMC_Mp[3][3] = 1.861112e+00f;
		AutoMATiC_DMC_Mp[3][4] = 3.180924e-01f;
		AutoMATiC_DMC_Mp[3][5] = 9.110921e-01f;
		AutoMATiC_DMC_Mp[3][6] = 1.170196e-01f;
		AutoMATiC_DMC_Mp[3][7] = 4.460175e-01f;
		AutoMATiC_DMC_Mp[3][8] = 4.304912e-02f;
		AutoMATiC_DMC_Mp[3][9] = 1.465848e-01f;
		AutoMATiC_DMC_Mp[3][10] = 1.157769e-02f;
		AutoMATiC_DMC_Mp[4][1] = 9.643260e-01f;
		AutoMATiC_DMC_Mp[4][2] = 1.835830e+00f;
		AutoMATiC_DMC_Mp[4][3] = 1.821377e-01f;
		AutoMATiC_DMC_Mp[4][4] = 5.259741e-01f;
		AutoMATiC_DMC_Mp[4][5] = 3.440136e-02f;
		AutoMATiC_DMC_Mp[4][6] = 1.506941e-01f;
		AutoMATiC_DMC_Mp[4][7] = 6.497578e-03f;
		AutoMATiC_DMC_Mp[4][8] = 4.317458e-02f;
		AutoMATiC_DMC_Mp[4][9] = 1.032264e-03f;
		AutoMATiC_DMC_Mp[4][10] = 9.614986e-03f;
		AutoMATiC_DMC_Mp[5][1] = 4.413404e+00f;
		AutoMATiC_DMC_Mp[5][2] = 9.502129e-01f;
		AutoMATiC_DMC_Mp[5][3] = 2.160545e+00f;
		AutoMATiC_DMC_Mp[5][4] = 3.495638e-01f;
		AutoMATiC_DMC_Mp[5][5] = 1.057677e+00f;
		AutoMATiC_DMC_Mp[5][6] = 1.285973e-01f;
		AutoMATiC_DMC_Mp[5][7] = 4.460175e-01f;
		AutoMATiC_DMC_Mp[5][8] = 4.304912e-02f;
		AutoMATiC_DMC_Mp[5][9] = 1.465848e-01f;
		AutoMATiC_DMC_Mp[5][10] = 1.157769e-02f;
		AutoMATiC_DMC_Mp[6][1] = 9.932621e-01f;
		AutoMATiC_DMC_Mp[6][2] = 1.952965e+00f;
		AutoMATiC_DMC_Mp[6][3] = 1.876030e-01f;
		AutoMATiC_DMC_Mp[6][4] = 5.595337e-01f;
		AutoMATiC_DMC_Mp[6][5] = 3.543362e-02f;
		AutoMATiC_DMC_Mp[6][6] = 1.603091e-01f;
		AutoMATiC_DMC_Mp[6][7] = 6.497578e-03f;
		AutoMATiC_DMC_Mp[6][8] = 4.317458e-02f;
		AutoMATiC_DMC_Mp[6][9] = 1.032264e-03f;
		AutoMATiC_DMC_Mp[6][10] = 9.614986e-03f;
		AutoMATiC_DMC_Mp[7][1] = 4.712837e+00f;
		AutoMATiC_DMC_Mp[7][2] = 9.816844e-01f;
		AutoMATiC_DMC_Mp[7][3] = 2.307130e+00f;
		AutoMATiC_DMC_Mp[7][4] = 3.611415e-01f;
		AutoMATiC_DMC_Mp[7][5] = 1.057677e+00f;
		AutoMATiC_DMC_Mp[7][6] = 1.285973e-01f;
		AutoMATiC_DMC_Mp[7][7] = 4.460175e-01f;
		AutoMATiC_DMC_Mp[7][8] = 4.304912e-02f;
		AutoMATiC_DMC_Mp[7][9] = 1.465848e-01f;
		AutoMATiC_DMC_Mp[7][10] = 1.157769e-02f;
		AutoMATiC_DMC_Mp[8][1] = 9.987274e-01f;
		AutoMATiC_DMC_Mp[8][2] = 1.986524e+00f;
		AutoMATiC_DMC_Mp[8][3] = 1.886352e-01f;
		AutoMATiC_DMC_Mp[8][4] = 5.691487e-01f;
		AutoMATiC_DMC_Mp[8][5] = 3.543362e-02f;
		AutoMATiC_DMC_Mp[8][6] = 1.603091e-01f;
		AutoMATiC_DMC_Mp[8][7] = 6.497578e-03f;
		AutoMATiC_DMC_Mp[8][8] = 4.317458e-02f;
		AutoMATiC_DMC_Mp[8][9] = 1.032264e-03f;
		AutoMATiC_DMC_Mp[8][10] = 9.614986e-03f;
		AutoMATiC_DMC_Mp[9][1] = 4.859422e+00f;
		AutoMATiC_DMC_Mp[9][2] = 9.932621e-01f;
		AutoMATiC_DMC_Mp[9][3] = 2.307130e+00f;
		AutoMATiC_DMC_Mp[9][4] = 3.611415e-01f;
		AutoMATiC_DMC_Mp[9][5] = 1.057677e+00f;
		AutoMATiC_DMC_Mp[9][6] = 1.285973e-01f;
		AutoMATiC_DMC_Mp[9][7] = 4.460175e-01f;
		AutoMATiC_DMC_Mp[9][8] = 4.304912e-02f;
		AutoMATiC_DMC_Mp[9][9] = 1.465848e-01f;
		AutoMATiC_DMC_Mp[9][10] = 1.157769e-02f;
		AutoMATiC_DMC_Mp[10][1] = 9.997596e-01f;
		AutoMATiC_DMC_Mp[10][2] = 1.996139e+00f;
		AutoMATiC_DMC_Mp[10][3] = 1.886352e-01f;
		AutoMATiC_DMC_Mp[10][4] = 5.691487e-01f;
		AutoMATiC_DMC_Mp[10][5] = 3.543362e-02f;
		AutoMATiC_DMC_Mp[10][6] = 1.603091e-01f;
		AutoMATiC_DMC_Mp[10][7] = 6.497578e-03f;
		AutoMATiC_DMC_Mp[10][8] = 4.317458e-02f;
		AutoMATiC_DMC_Mp[10][9] = 1.032264e-03f;
		AutoMATiC_DMC_Mp[10][10] = 9.614986e-03f;
		AutoMATiC_DMC_ftmp3 = dtablica(1,10,1,1);
		AutoMATiC_DMC_ftmp4 = dtablica(1,10,1,1);
		AutoMATiC_DMC_fconst = dtablica(1,10,1,10);
		AutoMATiC_DMC_fconst[1][1] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[1][2] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[1][3] = -5.104583e+00f;
		AutoMATiC_DMC_fconst[1][4] = -1.622249e+00f;
		AutoMATiC_DMC_fconst[1][5] = -7.603490e+00f;
		AutoMATiC_DMC_fconst[1][6] = -1.928652e+00f;
		AutoMATiC_DMC_fconst[1][7] = -8.826808e+00f;
		AutoMATiC_DMC_fconst[1][8] = -1.986524e+00f;
		AutoMATiC_DMC_fconst[1][9] = -9.425674e+00f;
		AutoMATiC_DMC_fconst[1][10] = -1.997455e+00f;
		AutoMATiC_DMC_fconst[2][1] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[2][2] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[2][3] = -1.264241e+00f;
		AutoMATiC_DMC_fconst[2][4] = -2.853981e+00f;
		AutoMATiC_DMC_fconst[2][5] = -1.729329e+00f;
		AutoMATiC_DMC_fconst[2][6] = -3.671660e+00f;
		AutoMATiC_DMC_fconst[2][7] = -1.900426e+00f;
		AutoMATiC_DMC_fconst[2][8] = -3.905929e+00f;
		AutoMATiC_DMC_fconst[2][9] = -1.963369e+00f;
		AutoMATiC_DMC_fconst[2][10] = -3.973048e+00f;
		AutoMATiC_DMC_fconst[3][1] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[3][2] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[3][3] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[3][4] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[3][5] = -5.104583e+00f;
		AutoMATiC_DMC_fconst[3][6] = -1.622249e+00f;
		AutoMATiC_DMC_fconst[3][7] = -7.603490e+00f;
		AutoMATiC_DMC_fconst[3][8] = -1.928652e+00f;
		AutoMATiC_DMC_fconst[3][9] = -8.826808e+00f;
		AutoMATiC_DMC_fconst[3][10] = -1.986524e+00f;
		AutoMATiC_DMC_fconst[4][1] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[4][2] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[4][3] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[4][4] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[4][5] = -1.264241e+00f;
		AutoMATiC_DMC_fconst[4][6] = -2.853981e+00f;
		AutoMATiC_DMC_fconst[4][7] = -1.729329e+00f;
		AutoMATiC_DMC_fconst[4][8] = -3.671660e+00f;
		AutoMATiC_DMC_fconst[4][9] = -1.900426e+00f;
		AutoMATiC_DMC_fconst[4][10] = -3.905929e+00f;
		AutoMATiC_DMC_fconst[5][1] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[5][2] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[5][3] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[5][4] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[5][5] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[5][6] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[5][7] = -5.104583e+00f;
		AutoMATiC_DMC_fconst[5][8] = -1.622249e+00f;
		AutoMATiC_DMC_fconst[5][9] = -7.603490e+00f;
		AutoMATiC_DMC_fconst[5][10] = -1.928652e+00f;
		AutoMATiC_DMC_fconst[6][1] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[6][2] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[6][3] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[6][4] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[6][5] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[6][6] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[6][7] = -1.264241e+00f;
		AutoMATiC_DMC_fconst[6][8] = -2.853981e+00f;
		AutoMATiC_DMC_fconst[6][9] = -1.729329e+00f;
		AutoMATiC_DMC_fconst[6][10] = -3.671660e+00f;
		AutoMATiC_DMC_fconst[7][1] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[7][2] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[7][3] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[7][4] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[7][5] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[7][6] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[7][7] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[7][8] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[7][9] = -5.104583e+00f;
		AutoMATiC_DMC_fconst[7][10] = -1.622249e+00f;
		AutoMATiC_DMC_fconst[8][1] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[8][2] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[8][3] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[8][4] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[8][5] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[8][6] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[8][7] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[8][8] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[8][9] = -1.264241e+00f;
		AutoMATiC_DMC_fconst[8][10] = -2.853981e+00f;
		AutoMATiC_DMC_fconst[9][1] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[9][2] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[9][3] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[9][4] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[9][5] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[9][6] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[9][7] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[9][8] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[9][9] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[9][10] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[10][1] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[10][2] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[10][3] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[10][4] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[10][5] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[10][6] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[10][7] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[10][8] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[10][9] = 0.000000e+00f;
		AutoMATiC_DMC_fconst[10][10] = 0.000000e+00f;
		AutoMATiC_DMC_btmp1 = dtablica(1,40,1,1);
		AutoMATiC_DMC_bvar = dtablica(1,40,1,2);
		AutoMATiC_DMC_bvar[1][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[1][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[2][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[2][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[3][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[3][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[4][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[4][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[5][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[5][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[6][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[6][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[7][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[7][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[8][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[8][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[9][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[9][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[10][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[10][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[11][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[11][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[12][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[12][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[13][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[13][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[14][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[14][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[15][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[15][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[16][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[16][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[17][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[17][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[18][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[18][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[19][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[19][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[20][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[20][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[21][1] = 1.000000e+00f;
		AutoMATiC_DMC_bvar[21][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[22][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[22][2] = 1.000000e+00f;
		AutoMATiC_DMC_bvar[23][1] = 1.000000e+00f;
		AutoMATiC_DMC_bvar[23][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[24][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[24][2] = 1.000000e+00f;
		AutoMATiC_DMC_bvar[25][1] = 1.000000e+00f;
		AutoMATiC_DMC_bvar[25][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[26][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[26][2] = 1.000000e+00f;
		AutoMATiC_DMC_bvar[27][1] = 1.000000e+00f;
		AutoMATiC_DMC_bvar[27][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[28][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[28][2] = 1.000000e+00f;
		AutoMATiC_DMC_bvar[29][1] = 1.000000e+00f;
		AutoMATiC_DMC_bvar[29][2] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[30][1] = 0.000000e+00f;
		AutoMATiC_DMC_bvar[30][2] = 1.000000e+00f;
		AutoMATiC_DMC_bvar[31][1] = -1.000000e+00f;
		AutoMATiC_DMC_bvar[31][2] = -0.000000e+00f;
		AutoMATiC_DMC_bvar[32][1] = -0.000000e+00f;
		AutoMATiC_DMC_bvar[32][2] = -1.000000e+00f;
		AutoMATiC_DMC_bvar[33][1] = -1.000000e+00f;
		AutoMATiC_DMC_bvar[33][2] = -0.000000e+00f;
		AutoMATiC_DMC_bvar[34][1] = -0.000000e+00f;
		AutoMATiC_DMC_bvar[34][2] = -1.000000e+00f;
		AutoMATiC_DMC_bvar[35][1] = -1.000000e+00f;
		AutoMATiC_DMC_bvar[35][2] = -0.000000e+00f;
		AutoMATiC_DMC_bvar[36][1] = -0.000000e+00f;
		AutoMATiC_DMC_bvar[36][2] = -1.000000e+00f;
		AutoMATiC_DMC_bvar[37][1] = -1.000000e+00f;
		AutoMATiC_DMC_bvar[37][2] = -0.000000e+00f;
		AutoMATiC_DMC_bvar[38][1] = -0.000000e+00f;
		AutoMATiC_DMC_bvar[38][2] = -1.000000e+00f;
		AutoMATiC_DMC_bvar[39][1] = -1.000000e+00f;
		AutoMATiC_DMC_bvar[39][2] = -0.000000e+00f;
		AutoMATiC_DMC_bvar[40][1] = -0.000000e+00f;
		AutoMATiC_DMC_bvar[40][2] = -1.000000e+00f;
		AutoMATiC_DMC_btmp2 = dtablica(1,40,1,2);
		AutoMATiC_DMC_b = dtablica(1,40,1,2);
		AutoMATiC_DMC_b[1][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[1][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[2][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[2][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[3][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[3][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[4][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[4][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[5][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[5][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[6][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[6][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[7][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[7][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[8][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[8][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[9][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[9][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[10][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[10][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[11][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[11][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[12][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[12][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[13][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[13][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[14][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[14][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[15][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[15][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[16][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[16][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[17][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[17][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[18][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[18][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[19][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[19][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[20][1] = 1.000000e-02f;
		AutoMATiC_DMC_b[20][2] = 1.000000e-02f;
		AutoMATiC_DMC_b[21][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[21][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[22][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[22][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[23][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[23][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[24][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[24][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[25][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[25][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[26][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[26][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[27][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[27][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[28][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[28][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[29][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[29][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[30][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[30][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[31][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[31][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[32][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[32][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[33][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[33][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[34][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[34][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[35][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[35][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[36][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[36][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[37][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[37][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[38][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[38][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[39][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[39][2] = 1.000000e+00f;
		AutoMATiC_DMC_b[40][1] = 1.000000e+00f;
		AutoMATiC_DMC_b[40][2] = 1.000000e+00f;
		dumax = dtablica(1,1,1,2);
		dumax[1][1] = 1.000000e-02f;
		dumax[1][2] = 1.000000e-02f;
		dumin = dtablica(1,1,1,2);
		dumin[1][1] = -1.000000e-02f;
		dumin[1][2] = -1.000000e-02f;
		umax = dtablica(1,1,1,2);
		umax[1][1] = 1.000000e+00f;
		umax[1][2] = 1.000000e+00f;
		umin = dtablica(1,1,1,2);
		umin[1][1] = -1.000000e+00f;
		umin[1][2] = -1.000000e+00f;
		return;
	}
	for(j=1;j<=10;++j) for(k=1;k<=1;++k) AutoMATiC_DMC_dUp[j][k] = 0;
	for(j=1;j<=10;++j) for(k=1;k<=1;++k) AutoMATiC_DMC_Yzad[j][k] = 0;
	for(j=1;j<=10;++j) for(k=1;k<=1;++k) AutoMATiC_DMC_Y[j][k] = 0;
	for(j=1;j<=2;++j) for(k=1;k<=1;++k) AutoMATiC_DMC_tmpu[j][k] = 0;
	AutoMATiC_DMC_itmp=1;
	for(AutoMATiC_DMC_i=1;AutoMATiC_DMC_i<=5;++AutoMATiC_DMC_i){
		for(AutoMATiC_DMC_j=1;AutoMATiC_DMC_j<=2;++AutoMATiC_DMC_j){
			AutoMATiC_DMC_dUp[AutoMATiC_DMC_itmp][1]=ad->du[ad->k-AutoMATiC_DMC_i][AutoMATiC_DMC_j-1];
			AutoMATiC_DMC_itmp=AutoMATiC_DMC_itmp+1;
		}
	}
	AutoMATiC_DMC_itmp=1;
	for(AutoMATiC_DMC_i=1;AutoMATiC_DMC_i<=5;++AutoMATiC_DMC_i){
		for(AutoMATiC_DMC_j=1;AutoMATiC_DMC_j<=2;++AutoMATiC_DMC_j){
			AutoMATiC_DMC_Yzad[AutoMATiC_DMC_itmp][1]=ad->z[AutoMATiC_DMC_j-1];
			AutoMATiC_DMC_itmp=AutoMATiC_DMC_itmp+1;
		}
	}
	AutoMATiC_DMC_itmp=1;
	for(AutoMATiC_DMC_i=1;AutoMATiC_DMC_i<=5;++AutoMATiC_DMC_i){
		for(AutoMATiC_DMC_j=1;AutoMATiC_DMC_j<=2;++AutoMATiC_DMC_j){
			AutoMATiC_DMC_Y[AutoMATiC_DMC_itmp][1]=ad->y[ad->k][AutoMATiC_DMC_j-1];
			AutoMATiC_DMC_itmp=AutoMATiC_DMC_itmp+1;
		}
	}
	for(j=1;j<=2;++j) for(k=1;k<=1;++k) AutoMATiC_DMC_e[j][k] = 0;
	for(AutoMATiC_DMC_i=1;AutoMATiC_DMC_i<=2;++AutoMATiC_DMC_i){
		AutoMATiC_DMC_e[AutoMATiC_DMC_i][1]=ad->z[AutoMATiC_DMC_i-1]-ad->y[ad->k][AutoMATiC_DMC_i-1];
	}
	iloczynab(AutoMATiC_DMC_Ke,AutoMATiC_DMC_e,AutoMATiC_DMC_dutmp1,2,2,2,1);
	iloczynab(AutoMATiC_DMC_Ku,AutoMATiC_DMC_dUp,AutoMATiC_DMC_dutmp2,2,10,10,1);
	sumaaa(AutoMATiC_DMC_dutmp1,AutoMATiC_DMC_dutmp2,AutoMATiC_DMC_du,2,1,-1);
	for(j=1;j<=2;++j) for(k=1;k<=1;++k) AutoMATiC_DMC_du[j][k] = 0;
	for(j=1;j<=2;++j) for(k=1;k<=1;++k) AutoMATiC_DMC_uk[j][k] = 0;
	for(AutoMATiC_DMC_i=1;AutoMATiC_DMC_i<=2;++AutoMATiC_DMC_i){
		AutoMATiC_DMC_uk[AutoMATiC_DMC_i][1]=ad->u[ad->k-1][AutoMATiC_DMC_i-1];
	}
	sumaaa(AutoMATiC_DMC_Yzad,AutoMATiC_DMC_Y,AutoMATiC_DMC_ftmp1,10,1,-1);
	iloczynab(AutoMATiC_DMC_Mp,AutoMATiC_DMC_dUp,AutoMATiC_DMC_ftmp2,10,10,10,1);
	sumaaa(AutoMATiC_DMC_ftmp1,AutoMATiC_DMC_ftmp2,AutoMATiC_DMC_ftmp3,10,1,-1);
	iloczynab(AutoMATiC_DMC_fconst,AutoMATiC_DMC_ftmp3,AutoMATiC_DMC_ftmp4,10,10,10,1);
	for(AutoMATiC_DMC_i=1;AutoMATiC_DMC_i<=10;++AutoMATiC_DMC_i){
		AutoMATiC_DMC_ftmp[AutoMATiC_DMC_i]=AutoMATiC_DMC_ftmp4[AutoMATiC_DMC_i][1];
	}
	iloczynab(AutoMATiC_DMC_bvar,AutoMATiC_DMC_uk,AutoMATiC_DMC_btmp1,40,2,2,1);
	sumaaa(AutoMATiC_DMC_b,AutoMATiC_DMC_btmp1,AutoMATiC_DMC_btmp2,40,2,1);
	for(AutoMATiC_DMC_i=1;AutoMATiC_DMC_i<=40;++AutoMATiC_DMC_i){
		AutoMATiC_DMC_btmp[AutoMATiC_DMC_i]=AutoMATiC_DMC_btmp2[AutoMATiC_DMC_i][1];
	}
	for(AutoMATiC_DMC_i=1;AutoMATiC_DMC_i<=2;++AutoMATiC_DMC_i){
		AutoMATiC_DMC_qpx[AutoMATiC_DMC_i]=0;
	}
	iloczynw(AutoMATiC_DMC_btmp,-1,AutoMATiC_DMC_btmp,40);pk();
	for(AutoMATiC_DMC_i=1;AutoMATiC_DMC_i<=2;++AutoMATiC_DMC_i){
		AutoMATiC_DMC_du[AutoMATiC_DMC_i][1]=AutoMATiC_DMC_qpx[AutoMATiC_DMC_i];
	}
	for(AutoMATiC_DMC_n=1;AutoMATiC_DMC_n<=2;++AutoMATiC_DMC_n){
		if(AutoMATiC_DMC_du[AutoMATiC_DMC_n][1]>dumax[1][AutoMATiC_DMC_n]){
			AutoMATiC_DMC_du[AutoMATiC_DMC_n][1]=dumax[1][AutoMATiC_DMC_n];
		}
		if(AutoMATiC_DMC_du[AutoMATiC_DMC_n][1]<dumin[1][AutoMATiC_DMC_n]){
			AutoMATiC_DMC_du[AutoMATiC_DMC_n][1]=dumin[1][AutoMATiC_DMC_n];
		}
		AutoMATiC_DMC_tmpu[AutoMATiC_DMC_n][1]=ad->u[ad->k-1][AutoMATiC_DMC_n-1]+AutoMATiC_DMC_du[AutoMATiC_DMC_n][1];
		if(AutoMATiC_DMC_tmpu[AutoMATiC_DMC_n][1]>umax[1][AutoMATiC_DMC_n]){
			AutoMATiC_DMC_tmpu[AutoMATiC_DMC_n][1]=umax[1][AutoMATiC_DMC_n];
		}
		if(AutoMATiC_DMC_tmpu[AutoMATiC_DMC_n][1]<umin[1][AutoMATiC_DMC_n]){
			AutoMATiC_DMC_tmpu[AutoMATiC_DMC_n][1]=umin[1][AutoMATiC_DMC_n];
		}
		AutoMATiC_DMC_du[AutoMATiC_DMC_n][1]=AutoMATiC_DMC_tmpu[AutoMATiC_DMC_n][1]-ad->u[ad->k-1][AutoMATiC_DMC_n-1];
	}
	for(j=1;j<=1;++j) for(k=1;k<=2;++k) control_value[j][k] = 0;
	for(AutoMATiC_DMC_n=1;AutoMATiC_DMC_n<=2;++AutoMATiC_DMC_n){
		control_value[1][AutoMATiC_DMC_n]=AutoMATiC_DMC_du[AutoMATiC_DMC_n][1];
	}

	set_current_control_increment(c,&(control_value[1][1])); // du is indexed starting with 1, therefore to maintain compatibility it is required to refer to first element of an actual array
}

void controller_setup(){
profiler_start(2);
    init_archive_data(&ad, 200, 200, 2, 2, 0, 0, 0.01);
    init_current_control(&cc,&ad);
    controller(NULL,NULL);
profiler_end(2);
}

void idle(){
profiler_start(13);
    const int k = 0;
	static char str[1000] = {0};

    sprintf(str, "x = [%f,%f,",ad.y[k][0], ad.y[k][1]);    write_string(str);
    sprintf(str,      "%f,%f,",ad.z[0], ad.z[1]);          write_string(str);
    sprintf(str,      "%f,%f,",ad.u[k-1][0],ad.u[k-1][1]); write_string(str);
    write_string("];\n\r");
profiler_end(13);
}

void loop(){
profiler_start(10);
    static int i = 0;
	if(i<  50){ ad.z[0] = -0.1; ad.z[1] =  0.2; }
	else      { ad.z[0] =  0.1; ad.z[1] = -0.2; }
    if(++i > 100) i = 0;
	
profiler_start(50);
	controller(&ad,&cc);
profiler_end(50);
	
    push_current_controls_to_archive_data(&cc,&ad);	
profiler_end(10);
}

void timeout(){
    while(1);
}
\end{lstlisting}
\end{document}

