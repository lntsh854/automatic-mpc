%%
% This file is part of AutoMATiC.
% AutoMATiC -- Automatic code generation based on the MATLAB and 
% C languages.
% 
% Copytight (C) 2018-2019 by Patryk Chaber. Developed within the 
% Warsaw University of Technology, Institute of Control and 
% Computation Engineering under supervision of Maciej Lawrynczuk. 
% All rights reserved.
% 
% AutoMATiC is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 3 of the License, or
% (at your option) any later version.
% 
% AutoMATiC is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with AutoMATiC.  If not, see <https://www.gnu.org/licenses/>.
%

classdef AutoMATiC_Generator_Active_Set < handle
    properties (Constant)
        %% CONSTANTS used for ,,dbg'' function
        DBG_NODE = 1
        DBG_CODEGEN = 2
        DBG_MATRIXSIZE = 3
        DBG_DECLARATIONS = 4
        DBG_CONSTANTS = 5
        DBG_OTHER = 99
        
        %% CONSTANTS used for ,,dbgPlot'' function
        DBGPLOT_EVALUATION = 1
    end
    properties
        dbg_types % types of debugging information to be shown
        dbg_plot_types % types of debugging information to be plotted
        root      % root of parsing tree
        constants % variables existing in the workspace to be daclared -- constants
        variables % variables created in the translated part to be declared -- variables
        matrices  % list of matrices (to be treated differently from integers and floats)
        code      % stores all the code generated by SimpleGenerator
        qpconf    % configuration of quadprog
    end
    methods
        function obj = AutoMATiC_Generator_Active_Set(toexecute,tree) 
            % Generates code in C from the syntax tree.
            %
            % Algorithm:
            % 0) debugging configuration is set
            % 1) executes in the base workspace all of the executable part
            % of code
            % 2a) collects all of the created types from assignments
            % (variables) -- no assignments can be done on the variables
            % from outside of translated code
            % 2b) the same for all of the for's
            % 3) evaluates all of the constant value calculations (e.g. 
            % x = 1+2+3 -->  x = 6;
            % and further 
            % y = zeros(x) --> y = zeros(6);
            % 4) gets sizes of matrices based on assignments (I could do it
            % during 2a) but this way I think it is more clear)
            % 5a) generate code
            % 5b) generate declarations
            obj.dbg_types = [];
            obj.dbg_plot_types = []; %[obj.DBGPLOT_EVALUATION];
            toexecute_all = join(toexecute); 
            evalin('base',toexecute_all{1});
            obj.root = tree;
            obj.constants = [];
            obj.variables = [];
            obj.matrices = {};
            obj.qpconf = struct();
            obj.variables = obj.getTypesFromFors(obj.variables);
            obj.variables = obj.getTypesFromAssignments(obj.variables);
            obj.root.assignIds({},1,[]);
            obj.dbgPlot(obj.root,'START',obj.DBGPLOT_EVALUATION);
            while(obj.tryEvaluatingExpressionsAndVariables()); end
            obj.dbgPlot(obj.root,'END',obj.DBGPLOT_EVALUATION);
            obj.getMatrixSize(); % it fills the obj.matrices array
            obj.findAllConstants();
            obj.code = obj.generate();
            obj.code = [obj.generateDeclarations(obj.variables, obj.constants, obj.matrices), obj.code];
            obj.code = ['void %s(ArchiveData * ad, CurrentControl * c){', newline,...
                             obj.indentCode(obj.code), newline,... 
                             obj.indentCode('set_current_control_increment(c,&(control_value[1][1])); // du is indexed starting with 1, therefore to maintain compatibility it is required to refer to first element of an actual array'),newline,...
                             '}',newline,...
            ];
        end
        function code = indentCode(~,code)
            if(isempty(code))
                return;
            end
            tmpcode = join(regexprep(split(code,newline),'(.*)','\t$1'),newline);
            code = tmpcode{1};
        end
        function findAllConstants(obj)
            cs = obj.findAll('VARIABLE');
            for i = 1:length(cs)
                c = cs{i};
                if(c == 'VARIABLE')
                    var = c;
                    id = var.children(1);
                    if(any(strcmp(obj.variables(:,1),id.value)))
                        obj.dbg(sprintf('There is already variable of name %s in obj.variables\n',id.value),obj.DBG_CONSTANTS);
                        continue;
                    elseif(startsWith(id.value,'AD_'))
                        obj.dbg(sprintf('Variable of name %s a special one\n',id.value),obj.DBG_CONSTANTS);
                        continue;
                    end
                    type = obj.getTypeOfExpression(var,[]);
                    obj.dbg(sprintf('Variable of name %s and type %s is a CONSTANT\n',id.value,type),obj.DBG_CONSTANTS);
                    if(isempty(obj.constants) || ~any(strcmp(id.value,obj.constants(:,1))))
                        obj.constants = [obj.constants; {id.value, type}];
                    end
                    if(length(var.children) > 1)
                        tmpnode = AutoMATiC_Node(var.type, var.value);
                        tmpnode.children = [tmpnode.children var.children(1)];
                        s = obj.getMatrixSize(tmpnode);
                        if(~isempty(s) && ~any(strcmp(obj.matrices(:,1),id.value)))
                            obj.matrices = [obj.matrices; {id.value},{s}];
                        end
                    end
                end     
            end
        end
        
        function code = generateDeclarations(obj,variables,constants,matrices)
            % Generates declaration of variables assigned (created) in the
            % part of code that is translated. There are three types of
            % variables used:
            % INTEGER --> int (I am not using fancy types like uint32_t)
            % REAL --> float (I assume that there is onlyu single precision
            % unit)
            % MATRIX --> float**
            %
            % IMPORTANT: All variables are declared as static!
            code = [];
            %for c = obj.todeclare'
            for c = [variables; constants]'
                if(obj.inQuadprog(c{1}))
                    continue;
                end
                type = 'void';
                if(strcmp(c{2},'INTEGER'))
                    type = 'long';
                elseif(strcmp(c{2},'REAL'))
                    type = 'float';
                elseif(strcmp(c{2},'MATRIX'))
                    if(isempty(matrices))
                        msize = [];
                    else
                        msize = matrices(strcmp(matrices(:,1),c{1}),2);
                    end
                    if(isempty(msize)) % this should be a ,,control_value'' variable
                        type = 'float**';
                    else
                        type = ['float',repmat('*',1,length(msize{1}))];
                    end
                end
                code = [code,...
                    sprintf('static %s %s;',type,c{1}),...
                    newline,...
                ]; %#ok<*AGROW>
            end
            tcode = [];
            for m = matrices'
                msize = m{2};
                if(length(msize) == 2 || length(msize) == 3)
                    if(~obj.inQuadprog(m{1}))
                        if(length(msize) == 2)
%                             tcode = [tcode, sprintf('%s = dtablica(1,%d,1,%d);',m{1},msize(1),msize(2)), newline ];
                            tcode = [tcode, sprintf('%s = darray(1,%d,1,%d);',m{1},msize(1),msize(2)), newline ];
                        elseif(length(msize) == 3)
%                             tcode = [tcode, sprintf('%s = dtablica3(1,%d,1,%d,1,%d);',m{1},msize(1),msize(2),msize(3)), newline ];
                            tcode = [tcode, sprintf('%s = darray3(1,%d,1,%d,1,%d);',m{1},msize(1),msize(2),msize(3)), newline ];
                        end
                    end
                    if(~any(strcmp(variables(:,1),m{1})))
                        obj.dbg(sprintf('%10s [+] is to be declared\n',m{1}),obj.DBG_DECLARATIONS);
                        tmpmatrix = evalin('base', [ m{1} ';']);
                        if(isdiag(tmpmatrix))
                            if(~any(strcmp(obj.variables(:,1),'j')))
                                obj.variables = [obj.variables; {'j', 'INTEGER'}];
                            end
                            if(~any(strcmp(obj.variables(:,1),'k')))
                                obj.variables = [obj.variables; {'k', 'INTEGER'}];
                            end
                            tcode = [tcode, ...
                                sprintf('for(j=1;j<=%d;++j) for(k=1;k<=%d;++k) %s[j][k] = 0.0f;',msize(1),msize(2),m{1}), ...
                                newline,...
                            ];
                            for i = 1:msize(1)
                                tcode = [tcode, ...
                                    sprintf('%s[%d][%d] = %ef;',m{1},i,i,tmpmatrix(i,i)), ...
                                    newline,...
                                ];        
                            end
                        else
                            for i = 1:msize(1)
                                for j = 1:msize(2)
                                    if(length(msize) == 2)
                                        tcode = [tcode, ...
                                            sprintf('%s[%d][%d] = %ef;',m{1},i,j,tmpmatrix(i,j)), ...
                                            newline,...
                                        ];                                
                                    elseif(length(msize) == 3)
                                        for k = 1:msize(3)
                                            tcode = [tcode, ...
                                                sprintf('%s[%d][%d][%d] = %ef;',m{1},i,j,k,tmpmatrix(i,j,k)), ...
                                                newline,...
                                            ];                                
                                        end
                                    end
                                end
                            end
                        end
                    end
                else
                     error('Matrix %s does has dimensionality of %s',m{1},mat2str(msize));
                end
            end
            qpcode = [];
            if(isfield(obj.qpconf,'Hid'))
                Aidexist = evalin('base',['exist(''' obj.qpconf.Aid ''');']);
                if(Aidexist)
                    Aidsize = evalin('base',['size(' obj.qpconf.Aid ');']);
                else
                    error('A matrix is not initialized -- this one must be a constant');
                end
                code = [code,...
                    sprintf('static float ** %s;',obj.qpconf.Hid),...
                    newline,...
                    sprintf('static float ** %s;',obj.qpconf.Aid),...
                    newline,...
                    sprintf('static float * %s;',obj.qpconf.fid),...
                    newline,...
                    sprintf('static float * %s;',obj.qpconf.bid),...
                    newline,...
                    sprintf('static float * %s;',obj.qpconf.xid),...
                    newline,...
                ];
                qpcode = [...
                    sprintf('defineconnum(%d);',Aidsize(1)),...
                    newline,...
                    sprintf('definevarnum(%d);',Aidsize(2)),...
                    newline,...
                    'initializeqp();',...
                    newline,...
                    sprintf('%s=obtainA();',obj.qpconf.Aid),...
                    newline,...
                    sprintf('%s=obtainG();',obj.qpconf.Hid),...
                    newline,...
                    sprintf('%s=obtainb();',obj.qpconf.bid),...
                    newline,...
                    sprintf('%s=obtaint();',obj.qpconf.fid),...
                    newline,...
                    sprintf('%s=obtainx();',obj.qpconf.xid),...
                    newline,...
                ];
                ids = [{obj.qpconf.Aid}, {obj.qpconf.Hid}];
                for id = 1:length(ids)
                    mid = ids{id};
                    tmpmatrix = evalin('base', [ mid ';']);
                    msize = size(tmpmatrix);
                    if(strcmp(obj.qpconf.Aid,mid))
                        tmpmatrix=-tmpmatrix;
                    end
                    for i = 1:msize(1)
                        for j = 1:msize(2)
                            if(length(msize) == 2)
                                qpcode = [qpcode, ...
                                    sprintf('%s[%d][%d] = %ef;',mid,i,j,tmpmatrix(i,j)), ...
                                    newline,...
                                ];                                
                            else
                                error('QP matrices have to have only two dimensions!');
                            end
                        end
                    end
                end
            end
            
            code = [
                code,...
                'if(ad == NULL){', ...
                newline, ...
                obj.indentCode(qpcode),...
                obj.indentCode(tcode),...
                obj.indentCode('return;'), ...
                newline, ...
                '}', ...
                newline, ...
            ];
        end
        function f = inQuadprog(obj,id)
            f = 0;
            if(isfield(obj.qpconf,'Hid') && strcmp(id,obj.qpconf.Hid))
                f = 1;
            elseif(isfield(obj.qpconf,'Aid') && strcmp(id,obj.qpconf.Aid))
                f = 1;
            elseif(isfield(obj.qpconf,'fid') && strcmp(id,obj.qpconf.fid))
                f = 1;
            elseif(isfield(obj.qpconf,'bid') && strcmp(id,obj.qpconf.bid))
                f = 1;
            elseif(isfield(obj.qpconf,'xid') && strcmp(id,obj.qpconf.xid))
                f = 1;
            end
        end
        
        function code = generate(obj,node)
            % Generates code of particular node. If second parameter is
            % ommited, then the root of tree is assumed.
            if(nargin == 1)
                node = obj.root;
            end
            if(node == 'ALL')
                code = obj.generateAll(node); 
            elseif(node == 'SCRIPT')
                code = obj.generateScript(node); 
            elseif(node == 'IF')
                code = obj.generateIf(node); 
            elseif(node == 'FOR')
                code = obj.generateFor(node); 
            elseif(node == 'IDENTIFIER')
                code = obj.generateIdentifier(node); 
            elseif(node == 'ASSIGNMENT')
                code = obj.generateAssignment(node); 
            elseif(node == 'SYMBOLORVALUE')
                code = obj.generateSymbolOrValue(node); 
            elseif(node == 'OPERATION')
                code = obj.generateOperation(node); 
            elseif(node == 'EXPRESSION')
                code = obj.generateExpression(node); 
            elseif(node == 'VARIABLE')
                code = obj.generateVariable(node); 
            elseif(node == 'INTEGER')
                code = obj.generateInteger(node); 
            elseif(node == 'REAL')
                code = obj.generateReal(node); 
            else
                error('Cannot generate type of "%s"',node.type);
            end
            code = join(code);
            obj.dbg(sprintf('NODE: %s, %s\n',node.type,class(code)),obj.DBG_NODE);
        end
        function code = generateSymbolOrValue(obj, node)
            % Generates code of SYMBOLORVALUE node by calling ,,generate''
            % on its only child.
            code = [...
                obj.generate(node.children(1)),...
            ];
            code = join(code);
            obj.dbg(sprintf('SYMBIOLORVALUE: "%s"\n',code),obj.DBG_CODEGEN);
        end
        function code = generateIdentifier(obj, node)
            % Generates code of IDENTIFIER node by returning the name of
            % the identifier (i.e. node's value)
            code = [...
                node.value,...
            ];
            code = join(code);
            obj.dbg(sprintf('IDENTIFIER: "%s"\n',code),obj.DBG_CODEGEN);
        end
        function code = generateIf(obj, node)
            % Generates code of IF node by generating:
            % if( [.1.] ){
            %    [.2.]
            %    [...]
            % }
            % where [.1.] is generated based on the EXPRESSION node,
            % whereas [.2.] is a list of SCRIPT nodes.
            code = [...
                'if(',...
                obj.generate(node.children(1)),...
                '){',...
                newline,...
            ];
            for i = 2:length(node.children)
                %J=join(regexprep(split(obj.generate(node.children(i)),newline),'(.*)','\t$1'),newline);
                code = [code,...
                        obj.indentCode(obj.generate(node.children(i))),...
                ];
            end
            code = [code,...
                '}',...
                newline,...
            ];
            code = join(code);
            obj.dbg(sprintf('IF: "%s"\n',code),obj.DBG_CODEGEN);
        end
        function code = generateFor(obj, node)
            % Generates code of FOR node by generating:
            % for( [.1.] = [.2.]; [.1.] <= [.3.];++[.1.]){
            %    [.4.]
            %    [...]
            % }
            % where [.1.] is generated based on the IDENTIFIER node,
            % whereas [.2.] and [.3.] are based on EXPRESSION node,
            % and [.4.] is a list of SCRIPT nodes.
            code = [...
                'for(',...
                obj.generate(node.children(1)),...
                '=',...
                obj.generate(node.children(2)),...
                ';',...
                obj.generate(node.children(1)),...
                '<=',...
                obj.generate(node.children(3)),...
                ';++',...
                obj.generate(node.children(1)),...                
                '){',...
                newline,...
            ];
            for i = 4:length(node.children)
                J=join(regexprep(split(obj.generate(node.children(i)),newline),'(.*)','\t$1'),newline);
                code = [code,...
                    J{1},...
                ];
            end
            code = [code,...
                '}',...
                newline,...
            ];
            code = join(code);
            obj.dbg(sprintf('FOR: "%s"\n',code),obj.DBG_CODEGEN);
        end
        function code = generateOperation(obj, node)
            % Generates operation sign based on OPERATION node (i.e. on the
            % value of the node, where the literal of the operation is
            % stored)
            code = [...
                node.value,...
            ];
            code = join(code);
            obj.dbg(sprintf('OPERATION: "%s"\n',code),obj.DBG_CODEGEN);
        end
        function code = generateVariable(obj, node)
            % Generates code of VARIABLE node by generating:
            % [.1.] [ [.2.] ][ [...] ]
            % e.g. y --> y
            % e.g. c(1) --> c[1]
            % e.g. A(1,3) --> A[1][3]
            % e.g. X(1,1,3) --> X[1][1][3]
            % ...
            % where [.1.] is an IDENTIFIER node, and [.2.] may be a list of
            % EXPRESSIONS
            identifier = node.children(1);
            special = 0;
            if(startsWith(identifier.value,'AD_'))
                special = 1;
                newidentifier = ['ad->' lower(identifier.value(4:end))];
                code = [...
                    newidentifier,...
                ];                
            else
                code = [...
                    identifier.value,...
                ];
            end
            if(special)
                for  i=2:length(node.children)
                    if(i~=length(node.children))
                        code = [code,...
                            '[',...
                            obj.generate(node.children(2)),...
                            ']',...
                        ];
                    else
                        code = [code,...
                            '[',...
                            obj.generate(node.children(i)),...
                            '-1',...
                            ']',...
                        ];
                    end
                end
            else
                for  i=2:length(node.children)
                    code = [code,...
                        '[',...
                        obj.generate(node.children(i)),...
                        ']',...
                    ];
                end
            end
            code = join(code);
            obj.dbg(sprintf('VARIABLE: "%s"\n',code),obj.DBG_CODEGEN);
        end
        function code = generateExpression(obj, node)   
            % Generates code of EXPRESSION node by generating:
            % ([.1.])
            % or
            % [.1.] [.2.] [.3.]
            % Where if there is only one child, [.1.] is an EXPRESSION
            % node, whereas if there are 3 children, first one is an
            % SYMBOLORVALUE node, [.2.] is an OPERATION node, and [.3.] is
            % an EXPRESSION node which allows recurrsion.
            code = [...
                obj.generate(node.children(1)),...
            ];         
            if(length(node.children) == 1)
                if(node.children(1)=='EXPRESSION')
                    code = ['(' code ')'];
                end
            elseif(node.children(1) == 'MATRIX' || node.children(3) == 'MATRIX')
                error('NO MATRIX IN EXPRESSIONS ALLOWED!')
            else
                code = [code...
                    obj.generate(node.children(2)),...
                    obj.generate(node.children(3)),...
                ];
            end
            code = join(code);  
            obj.dbg(sprintf('EXPRESSION: "%s"\n',code),obj.DBG_CODEGEN); 
        end
        function code = generateAll(obj, node)
            % Generates code of ALL node by generating all of its children
            % as SCRIPT nodes. In each parsing tree there have to be
            % exactly one of those ALL nodes, and they are treated as
            % roots.
            code = [];
            for c = node.children
                code = [code,...
                    obj.generate(c),...
                ];             
            end
            code = join(code);
            obj.dbg(sprintf('ALL: "%s"\n',code),obj.DBG_CODEGEN);  
        end
        function code = generateScript(obj, node)
            % Generates code of SCRIPT node by generating its only child as
            % ASSIGNMENT, FOR or IF node. This node is only for
            % aggregation.
            code = [...
                obj.generate(node.children(1)),...
            ];             
            code = join(code);
            obj.dbg(sprintf('SCRIPT: "%s"\n',code),obj.DBG_CODEGEN);
        end
        function code = generateAssignment(obj, node)
            % Generates code of ASSIGNMENT node by generating:
            % [.1.] = [.2.];
            % Where [.1.] is a code based on IDENTIFIER node (not
            % VARIABLE node!), and the [.2.] is either EXPRESSION node or
            % ZEROS node. 
            % ZEROS node are not generated separately because
            % of its close connection to the assignment node. Therefore if
            % there is a ZERO node, then instead of generating simple
            % assignment code, nested looped assignment is created.
            % e.g. from 
            % Y = zeros(20,1);
            % there is generated following code
            % for(j=1;j<=20;++j)
            % 	for(k=1;k<=1;++k)
            % 		Y[j][k] = 0;
            %
            % There is also another special situation to be handled. If the
            % assignment is of EXPRESSION which results in MATRIX and is
            % stored in this way, speciall function must be used for this
            % purpose.
            code = [];
            
            idref= (length(node.children(1).children)>1);
            id   = node.children(1).children(1);
            
            if(node.children(2) == 'ZEROS')
                zeross = node.children(2);
                formatt = 'for(%s=1;%s<=%s;++%s) ';
                letter = 'jklmn';
                if(length(zeross.children) > length(letter))
                    error('Too many loops, too little letters!');
                end
                for i = 1:length(zeross.children)
                    if(~any(strcmp(obj.variables(:,1),letter(i))))
                        obj.variables = [obj.variables; {letter(i), 'INTEGER'}];
                    end
                    code = [code,...
                        sprintf(formatt,letter(i),letter(i),obj.generate(zeross.children(i)),letter(i)),...
                    ];
                end
                code = [code,...
                    obj.generate(node.children(1)),...
                ];
                for i = 1:length(zeross.children)
                    code = [code,...
                        '[',...
                        letter(i),...
                        ']',...
                    ];
                end
                code = [code,...
                    ' = 0;',...
                    newline,...
                ];
            elseif(node.children(2) == 'QUADPROG')
                code = obj.generateQuadprogAssignment(node);
            elseif(~idref && strcmp(obj.variables(strcmp(obj.variables(:,1),id.value),2),'MATRIX'))
                target = node.children(1).children(1).value;
                expr = node.children(2);
                lhsid = expr.children(1).children(1).value;
                rhsid = expr.children(3).children(1).value;
                lhssize = obj.matrices{strcmp(obj.matrices(:,1),lhsid),2};
                rhssize = obj.matrices{strcmp(obj.matrices(:,1),rhsid),2};
                
                operation = expr.children(2).value;
                switch operation
                    case {'+','-'}
                        if(strcmp(operation,'+')); multiplier = 1;
                        else; multiplier = -1;
                        end
                        code = [ ...
%                             sprintf('sumaaa(%s,%s,%s,%d,%d,%d);',lhsid,rhsid,target,lhssize(1),lhssize(2),multiplier)...
                            sprintf('sumaa(%s,%s,%s,%d,%d,%d);',lhsid,rhsid,target,lhssize(1),lhssize(2),multiplier)...
                            newline ...
                        ];
                    case {'*'}
                        code = [...
%                             sprintf('iloczynab(%s,%s,%s,%d,%d,%d,%d);',lhsid,rhsid,target,lhssize(1),lhssize(2),rhssize(1),rhssize(2))...
                            sprintf('productab(%s,%s,%s,%d,%d,%d,%d);',lhsid,rhsid,target,lhssize(1),lhssize(2),rhssize(1),rhssize(2))...
                            newline ...
                        ];
                            
                    case {'''*'} % transposition and multiplication
                        code = [...
%                             sprintf('iloczynatb(%s,%s,%s,%d,%d,%d,%d);',lhsid,rhsid,target,lhssize(1),lhssize(2),rhssize(1),rhssize(2))...
                            sprintf('productatb(%s,%s,%s,%d,%d,%d,%d);',lhsid,rhsid,target,lhssize(1),lhssize(2),rhssize(1),rhssize(2))...
                            newline ...
                        ];
                    otherwise
                        error('Unsupported operation ''%s''.',operation);
                end
            else
                code = [...
                    obj.generate(node.children(1)),...
                    '=',...
                    obj.generate(node.children(2)),...
                    ';',...
                    newline,...
                ];  
            end
            code = join(code);
            obj.dbg(sprintf('ASSIGNMENT: "%s"\n',code),obj.DBG_CODEGEN);
        end
        function code = generateQuadprogAssignment(obj,node)
            code = ['QUADPROG'];
            xvar = node.children(1);
            xid = xvar.children(1);
            qpnode = node.children(2);
            Hid = qpnode.children(1);
            fid = qpnode.children(2);
            Aid = qpnode.children(3);
            bid = qpnode.children(4);
            
            obj.qpconf.xid = xid.value;
            obj.qpconf.Hid = Hid.value;
            obj.qpconf.fid = fid.value;
            obj.qpconf.Aid = Aid.value;
            obj.qpconf.bid = bid.value;

            Aidexist = evalin('base',['exist(''' obj.qpconf.Aid ''');']);
            if(Aidexist)
                Aidsize = evalin('base',['size(' obj.qpconf.Aid ');']);
            else
                error('A matrix is not initialized -- this one must be a constant');
            end
            
            code = [
                sprintf('productv(%s,-1,%s,%d);',obj.qpconf.bid,obj.qpconf.bid,Aidsize(1)),...
                'qp();', ...
                newline,...
            ];            
        end        
        function code = generateReal(obj,node)
            % Generates code of REAL node by inserting its value.
            code = [...
                node.value,'f',...
            ];
            code = join(code);
            obj.dbg(sprintf('REAL: "%s"\n',code),obj.DBG_CODEGEN);
        end
        function code = generateInteger(obj,node)
            % Generates code of INTEGER node by inserting its value.
            code = [...
                char(node.value),...
            ];
            code = join(code);
            obj.dbg(sprintf('INTEGER: "%s"\n',code),obj.DBG_CODEGEN);
        end
        function type = maxType(obj, types)
            % Returns the most general type of variable based on the types
            % of variables tested.
            % e.g. (MATRIX, REAL) -> MATRIX
            % e.g. (REAL, REAL) -> REAL
            % e.g. (INTEGER, UNKNOWN) -> INTEGER
            % e.g. (INTEGER, MATRIX) -> MATRIX
            % List of types can be longer than two elements.
            % e.g. (INT, REAL, MATRIX) -> MATRIX
            % e.g. (INT, REAL, INT) -> REAL
            if(length(types) == 2)
                if(strcmp('MATRIX',types{1}) || strcmp('MATRIX',types{2}))
                    type = 'MATRIX';
                elseif(strcmp('REAL',types{1}) || strcmp('REAL',types{2}))
                    type = 'REAL';
                elseif(strcmp('INTEGER',types{1}) || strcmp('INTEGER',types{2}))
                    type = 'INTEGER';
                else
                    type = 'UNKONOWN';
                end
            else
                type = 'UNKNOWN';
                for i = 1:length(types)
                    type = obj.maxType({types{i},type});
                end
            end
        end
        function [type, variables] = determineTypeOf(obj, id, variables)
            % Determines type of variable with a given identifier, based on
            % list of known variables. This method also extends this list
            % of known variables.
            % Algorithm:
            % 0) If no variables list is given, then it blows up.
            % Otherwise:
            % 1) Try to find identifier in the given list of known
            % variables. If it is there -- return its known type.
            % 2) If identifier is not known (is not in the list), then
            % check if this identifier is in the base workspace, then:
            %   I) if its length is greater than 1, its MATRIX,
            %   II) else if its rounded value is the same as its exact
            %   value, then it is INTEGER,
            %   III) else if it is numeric value, then it is REAL,
            %   IIII) else it is unknown (e.g. for char, or struct),
            %   IIIII) append detected type to the list of known variables.
            % 3) If it also doesn't exist in the base workspace, then the
            % variable is used before it is known -- error.
            % 
            if(nargin == 3) 
                [defined, type] = obj.findIdentifier(id.value,variables);
                if(defined) % if defined
                    return;
                else % if not defined yet
                    existin=@(var)(evalin('base',sprintf('exist(''%s'',''var'')',var)));
                    if(existin(id.value)) % check if exists in base workspace
                        tmpvar = evalin('base',[id.value ';']);
                        if(length(tmpvar) > 1)
                            type = 'MATRIX';
                        elseif(floor(tmpvar)==tmpvar) % have to manually check if it is int
                            type = 'INTEGER';
                        elseif(isnumeric(tmpvar))
                            type = 'REAL';
                        else
                            type = 'UNKNOWN';
                        end
                        variables = [variables; {id.value, type}];
                    else % if doesn't exists
                        error('This should not happen -- that means that there is no variable '' %s '' defined yet',id.value);
                        %[type, variables] = obj.determineTypeOf(id,variables,obj.tree);
                        %obj.todeclare = [obj.todeclare; {id.value, type}];
                    end            
                end
            else
                type = 'INTEGER';
            end     
        end
        function [f, t] = findIdentifier(obj,id,variables)
            % Checks if the given identifier exists in the list of known
            % variables. If yes its known type is returned, else it returns
            % empty string for a type and value f is set to 0 to indicate
            % failure in finding.
            f = 0;
            t = '';
            for vars = variables'
                if(strcmp(vars{1},id))
                    f = 1;
                    t = vars{2};
                end
            end
        end
        function code = getCode(obj)
            % Returns the string containing generated code.
            code = obj.code;
        end
        
        function s = getMatrixSize(obj,node)
            % Determines size of matrices used in the translated code.
            %
            % If two arguments are passed, then this method returns
            % dimension of the node's value. Return value should be
            % interpreted as follows:
            % [] -- size could not be determined
            % 0 -- this node represents integer or real value
            % otherwise -- returned vector contains consecutive dimensions
            % (including e.g. [1], which should be returned for matrix e.g.
            % X = [1];
            %
            % Algorithms is as follows:
            % 1) Find all nodes of type ASSIGNMENT,
            % 2) For all of those nodes:
            % 2a) If its second child is of type ZEROS, then based on the
            % children of this node get list of dimensions' values.
            % 2b) Store this information in the ,,obj.matrices''
            % 3) Again, for all of those nodes:
            % 3a) Check if its second child is of type EXPRESSION, if not,
            % go to the next iteration. Assume, that this child is named X.
            % 3b) Check if the left hand side of ASSIGNMENT is a reference,
            % not the whole matrix. If not -- go to next iteraton.
            % 3c) If there is an entry in the ,,obj.variables'' array,
            % where first element equals to the identifier on the left hand
            % side of ASSIGNMENT, and the second one is a 'MATRIX', then:
            %    I) Determine size of first and third component of
            %    expresion (we assume that it is NOT another EXPRESSION!)
            %    II) If any of those is empty -- throw error.
            %    III) Based on the value of operator, decide how to
            %    calculate final size of the left hand side identifier of
            %    matrix
            %    IIII) If it doesn't exist, add new entry in the
            %    ,,obj.matrices'' array.
            s = [];
            if(nargin > 1) % if we are here, then the variable is found on obj.variable
                if(node == 'INTEGER' || node == 'REAL' || (node == 'VARIABLE' && length(node.children) > 1))
                    s = 0;
                elseif(node == 'VARIABLE' && length(node.children) == 1) % double check?
                    id = node.children(1);
                    if(any(strcmp(obj.variables(:,1),id.value)))
                        t = obj.variables{strcmp(obj.variables(:,1),id.value),2};
                        if(strcmp(t,'INTEGER') || strcmp(t,'REAL'))
                            s = 0;
                        elseif(strcmp(t,'MATRIX'))
                            if (any(strcmp(obj.matrices(:,1),id.value)) ) % is it on the list of matrices?
                                s = obj.matrices{strcmp(obj.matrices(:,1),id.value),2};
                            else
                            end
                        end
                    else
                        s = evalin('base',['size(' id.value ');']);
                        if(max(s) == 1)
                            s = 0;
                        end
                    end
                    
                else 
                    error('Node could not be found');
                end
                    
                return
            end
            ass = obj.findAll('ASSIGNMENT');
            for i = 1:length(ass)
                if(ass{i}.children(2) == 'ZEROS')
                    zrs = ass{i}.children(2);
                    tmp = [];
                    for n = 1:length(zrs.children)
                        if(zrs.children(n) == 'INTEGER')
                            tmp = [tmp, str2double(zrs.children(n).value)];
                        else
                            tmp = [];
                            break;
                        end
                    end
                    id = {ass{i}.children(1).children(1).value};
                    if(~isempty(tmp))
                        obj.matrices = [obj.matrices; id,tmp];
                    end
                    
                end
            end
            for i = 1:length(ass)
                if(ass{i}.children(2) == 'EXPRESSION')
                    expr = ass{i}.children(2);
                    idref= (length(ass{i}.children(1).children)>1);
                    id   = ass{i}.children(1).children(1);
                    
                    if(~idref && strcmp(obj.variables(strcmp(obj.variables(:,1),id.value),2),'MATRIX')) % is a known variable
                        xl = expr.children(1);
                        xr = expr.children(3);
                        xlsize = obj.getMatrixSize(xl);
                        xrsize = obj.getMatrixSize(xr);
                        if(isempty(xlsize)||isempty(xrsize))
                            error('Could not get size of variable');
                        end
                        
                        operation = expr.children(2).value;
                        xsize = [];
                        switch operation
                            case {'+','-'}
                                xsize = xlsize;
                                if(xlsize(1,1) == 0); xsize = xrsize; end
                            case {'*'}
                                if((length(xlsize) >= 1) && (length(xrsize) >= 2))
                                    xsize = [xlsize(1) xrsize(2)];
                                end
                                if(xlsize(1,1) == 0); xsize = xrsize; end
                                if(xrsize(1,1) == 0); xsize = xlsize; end
                            case {'''*'} % transposition and multiplication
                                if((length(xlsize) >= 2) && (length(xrsize) >= 2))
                                    xsize = [xlsize(2) xrsize(2)];
                                end
                                if((xlsize(1,1) == 0) && (length(xrsize) >= 2)); xsize = [xrsize(2) xrsize(1)]; end
                                if((xrsize(1,1) == 0) && (length(xlsize) >= 2)); xsize = [xlsize(2) xlsize(1)]; end
                            otherwise
                                error('Unsupported operation ''%s''.',operation);
                        end
                        obj.dbg(sprintf('%s | LEFT: %s; RIGHT: %s; --> %s \n',id.value,mat2str(xlsize),mat2str(xrsize),mat2str(xsize)),obj.DBG_MATRIXSIZE);
                        if(~any(strcmp(obj.matrices(:,1),id.value)))
                            obj.matrices = [obj.matrices; {id.value},{xsize}];
                        end
                        if((xlsize(1,1) ~= 0) && ~any(strcmp(obj.matrices(:,1),xl.children(1).value)))
                            obj.matrices = [obj.matrices; {xl.children(1).value},{xlsize}];
                        end
                        if((xrsize(1,1) ~= 0) && ~any(strcmp(obj.matrices(:,1),xr.children(1).value)))
                            obj.matrices = [obj.matrices; {xr.children(1).value},{xrsize}];
                        end
                    elseif(idref)
                        obj.dbg(sprintf('%s is only referenced here...\n',id.value),obj.DBG_MATRIXSIZE);
                    else
                        obj.dbg(sprintf('%s is NOT a MATRIX\n',id.value),obj.DBG_MATRIXSIZE);
                    end
                end
            end            
        end
        function [type, sizeof] = getTypeOfExpression(obj,node,variables)
            % Determines type of expression based on the type of its
            % children. This function uses recursion to determine type of
            % expression. If an IDENTIFIER node is detected, its analysis
            % may change (extend) the content of list of known variables.
            if(node == 'EXPRESSION')
                if(length(node.children) > 1)
                    type = obj.maxType({obj.getTypeOfExpression(node.children(1),variables),...
                                   obj.getTypeOfExpression(node.children(3),variables)});  
                else
                    type = obj.maxType({'UNKNOWN',obj.getTypeOfExpression(node.children(1),variables)});
                end
            elseif(node == 'VARIABLE')
                type = obj.getTypeOfExpression(node.children(1),variables);
            elseif(node == 'IDENTIFIER')
                [type, variables] = obj.determineTypeOf(node,variables);
            elseif(node == 'ZEROS')
                sizeof = 0;
                type = 'MATRIX';
            elseif(node == 'INTEGER')
                type = 'INTEGER';
            elseif(node == 'REAL')
                type = 'REAL';
            else
                type = 'UNKNOWN';
            end
        end
        function variables = getTypesFromFors(obj,variables)
            % Creates an array (cell to be exact) of identifiers and their
            % types based on all known FOR nodes. This indicates that all
            % found identifiers will have type of INTEGER, as no other
            % variables are allowed in the place of first child of FOR
            % node.
            %
            % Entries in the array are unique in terms of occurance of
            % identifiers.
            fors = obj.findAll('FOR');
            for i = 1:length(fors)
                identifier = fors{i}.children(1);
                variables = [variables; {identifier.value, 'INTEGER'}];
            end
            unique_ids = unique(variables(:,1));
            unique_vars = cell(length(unique_ids),2);
            for i = 1:length(unique_ids)
                found = variables(strcmp(variables(:,1),unique_ids(i)),:);
                unique_vars(i,:) = found(1,:);
            end
            variables = unique_vars;
        end
        function variables = getTypesFromAssignments(obj,variables)
            % Creates an array (cell to be exact) of identifiers and their
            % types based on all known ASSIGNMENT nodes. The type is
            % determined only for the left hand side of assignment.
            % Therefore, for variables with more children than 1 (i.e. with
            % indexes determining the element position), the assumed type
            % of identifier (first child) is MATRIX. Otherwise, the type is
            % determined based on the type of right hand side of the
            % assignment.
            %
            % Entries in the array are unique in terms of occurance of
            % identifiers.
            ass = obj.findAll('ASSIGNMENT');
            for i = 1:length(ass)
                variable = ass{i}.children(1);
                identifier = variable.children(1);
                if(length(variable.children) > 1)
                    indexed = 1;
                    variables = [variables; {identifier.value, 'MATRIX'}];
                else
                    indexed = 0;
                    type = obj.getTypeOfExpression(ass{i}.children(2),variables);
                    variables = [variables; {identifier.value, type}];
                end
            end
            unique_ids = unique(variables(:,1));
            unique_vars = cell(length(unique_ids),2);
            for i = 1:length(unique_ids)
                found = variables(strcmp(variables(:,1),unique_ids(i)),:);
                unique_vars(i,:) = found(1,:);
            end
            variables = unique_vars;
        end
        function [f, v, n] = isConstantIntegerVariable(obj,node)
            % Returns information about if the node contains INTEGER,
            % VARIABLE or contant value defined outside of translated part
            % of code. Also if the identifier of the variable starts with
            % ,,AD_'', this is assumed to be contantly changing -- names
            % starting with ,,AD_'' are treated in a special manner.
            %
            % The value of node is assumed to be constant if:
            % 1) Its type is INTEGER.
            % 2) It is a VARIABLE with one child, and its IDENTIFIER
            % exists in base workspace.
            % The value of node is certainly not constant if:
            % 1) It is a VARIABLE and its IDENTIFIER name starts with
            % ,,AD_''.
            % 2) It is a VARIABLE and its IDENTIFIER name is on the list of
            % known variables.
            % If none of the above is true, then the value is assumed not
            % to be constant.
            n = '';
            v = 0;
            f = 0;
            if(node == 'INTEGER' || node == 'REAL')
                f = 1;
                tmpvar = evalin('base',join([node.value ';']));
                v = tmpvar;
                n = join(node.value);
            elseif(node == 'VARIABLE' && length(node.children) == 1) % variable can be even a MATRIX
                if(startsWith(node.children(1).value,'AD_'))
                    f = 0;
                elseif(obj.isIdentifierIn(node.children(1).value,obj.variables))
                    f = 0;
                else
                    tmpvar = evalin('base',[node.children(1).value ';']);
                    if(length(tmpvar) == 1) % is not matrix, and its value is integer
                        f = 2;
                        v = tmpvar;
                        n = join(node.children(1).value);
                    end
                end
            else
                f = 0;
            end
        end
        function [sthdone] = tryEvaluatingExpressionsAndVariables(obj)
            % Evaluates nodes of type EXPRESSION and VARIABLE with their
            % values if its known and constant.
            %
            % First all the EXPRESSION nodes are analyzed, then, the
            % VARIABLES nodes are checked. After first modyfication of the
            % node, this function execution is terminated. This thus method
            % requires to be executed in a loop, until the returned value
            % is equal to 1.
            %
            % For each of EXPRESSION nodes, the following is performed:
            % 1) Number of its children is tested -- if 1, then go to 2a), 
            % else, go to 3a).
            % 2a) If value of this node is constant, then this node is
            % substituted with a newly created node of type INTEGER, and
            % value of this node.
            % 2b) Else nothing happens
            % 3a) First and third child is tested for being a constant. If
            % both are constant, then this node is substituted with a newly
            % created node of type INTEGER, and value of operation (second
            % child) performed on first and third child.
            %
            % For each of VARIABLE nodes, the following is performed:
            % 1) If value of this node is constant, then this node is
            % substituted with a newly created node of type INTEGER, and
            % value of this node.
            % 2) Else nothing happens
            sthdone = 0;
            exs = obj.findAll('EXPRESSION');
            for i = 1:length(exs)
                if(length(exs{i}.children) == 1)
                    node = exs{i}.children(1);
                    [f,v,n] = obj.isConstantIntegerVariable(node);
                    if(f)
                        obj.dbgPlot(exs{i}.parent,'BEFORE_(E)',obj.DBGPLOT_EVALUATION);
                        obj.substituteNodes(exs{i},AutoMATiC_Node('INTEGER',join(mat2str(v))));
                        sthdone = 1;
                        obj.dbgPlot(exs{i}.parent,'AFTER_(E)',obj.DBGPLOT_EVALUATION);
                        return;
                    end
                else
                    lnode = exs{i}.children(1);
                    mnode = exs{i}.children(2);
                    rnode = exs{i}.children(3);
                    [f1,v1,n1] = obj.isConstantIntegerVariable(lnode);
                    [f2,v2,n2] = obj.isConstantIntegerVariable(rnode);
                    if(f1 && f2)
                        obj.dbgPlot(exs{i}.parent,'BEFORE_E',obj.DBGPLOT_EVALUATION);
                        newvalue = eval(join([mat2str(v1) mnode.value mat2str(v2)]));
                        obj.substituteNodes(exs{i},AutoMATiC_Node('INTEGER',join(mat2str(newvalue))));
                        sthdone = 1;
                        obj.dbgPlot(exs{i}.parent,'AFTER_E',obj.DBGPLOT_EVALUATION);
                        return;
                    end
                end
            end
            vars = obj.findAll('VARIABLE');
            for i = 1:length(vars)
                if(length(vars{i}.children) == 1)
                    [f,v,n] = obj.isConstantIntegerVariable(vars{i});
                    if(f)
                        obj.dbgPlot(vars{i}.parent,'BEFORE_V',obj.DBGPLOT_EVALUATION);
                        if(floor(v)==v) % is not matrix, and its value is integer
                            obj.substituteNodes(vars{i},AutoMATiC_Node('INTEGER',join(mat2str(v))));
                        elseif(isnumeric(v))
                            obj.substituteNodes(vars{i},AutoMATiC_Node('REAL',join(mat2str(v))));
                        end
                        sthdone = 1;
                        obj.dbgPlot(vars{i}.parent,'AFTER_V',obj.DBGPLOT_EVALUATION);
                        return;
                    end
                end
            end
            
        end
        function substituteNodes(obj,old,new)
            % Substitutes selected node with new one by finding selected
            % node on the list of its parent children and changing its
            % value with a new node.
            for i = 1:length(old.parent.children)
                if(old.parent.children(i).id == old.id)
                    new.id=old.id;
                    old.parent.children(i) = new;
                    break;
                end
            end
        end
        function f = isIdentifierIn(obj,id,variables)
            % Checks if an identifier is contained in the first column of
            % the cell array variables.
            f = any(strcmp(variables(:,1),id));
        end
        function found = findAll(obj,type,node)
            % Returns all nodes of selected type. If no starting node is
            % selected, then the root is assumed. The search algorithm is
            % depth first.
            if(nargin == 2)
                node = obj.root;
            end
            found = {};
            if(node == type)
                found = [found, {node}];
            end
            for c = node.children
                found = [found, obj.findAll(type,c)];
            end
        end
        function disp(obj)
            % Displays code.
            fprintf('%s\n',obj.code);
        end
        
        function dbg(obj,s,t)
            % Prints debugging information based on the list of selected
            % types of messages.
            if(any(ismember(obj.dbg_types,t)))
                fprintf('[DD] (%2d) %s',t,s);
            end
        end
        
        function dbgPlot(obj,p,pname,t)
            % Performes plot function on selected objec based on the list
            % of selected types of messages .
            if(any(ismember(obj.dbg_plot_types,t)))
                plot(p,pname);
            end
        end
        
%% ABANDONNED FUNCTIONS
%         function code = generateCondition(obj, node)
%             code = [...
%                 obj.generate(node.children(1)),...
%             ];         
%             if(length(node.children) > 1)
%                 code = [code...
%                     obj.generate(node.children(2)),...
%                     obj.generate(node.children(3)),...
%                 ];
%             end
%             
%             fprintf('CONDITION: "%s"\n',code);   
%         end
%         function code = generateComparison(obj, node)
%             code = [...
%                 node.value,...
%             ];
%             fprintf('comparison: "%s"\n',code);
%         end
    end
end