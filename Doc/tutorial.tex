\documentclass[a4paper,titlepage,11pt,twosides,floatssmall]{article}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[OT1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{url}
\usepackage{tikz}
\usetikzlibrary{arrows,calc,decorations.markings,math,arrows.meta}
\usepackage{rotating}
\usepackage[percent]{overpic}
\usepackage[cp1250]{inputenc}
\usepackage{xcolor}
\usepackage{pgfplots}
\usetikzlibrary{pgfplots.groupplots}
\usepackage{listings}
\usepackage{matlab-prettifier}
\usepackage{enumitem,amssymb}
\definecolor{szary}{rgb}{0.95,0.95,0.95}
\usepackage{siunitx}
\sisetup{detect-weight,exponent-product=\cdot,output-decimal-marker={,},per-mode=symbol,binary-units=true,range-phrase={-},range-units=single}
\SendSettingsToPgf
%konfiguracje pakietu listings

\lstset{
	escapeinside = {@}{@},
	breaklines=true,
	tabsize=2,
	captionpos=t,
	xleftmargin=2pt,
	showstringspaces=false,
	aboveskip=0em,
  belowskip=0em,
  basicstyle=\footnotesize\ttfamily,
}

\lstdefinestyle{customlatex}{
	basicstyle=\footnotesize\ttfamily,
	%basicstyle=\small\ttfamily,
}

\definecolor{matlabtext}{HTML}{000000}
\definecolor{matlabbg}{HTML}{FFFFFF}
\definecolor{matlabkeywords}{HTML}{0000FF}
\definecolor{matlabcomments}{HTML}{228B22}
\definecolor{matlabstring}{HTML}{A020F0}
\definecolor{matlaberror}{HTML}{FF0000}
\definecolor{matlabvariable}{HTML}{000000}

\lstdefinestyle{myc}{
	language=C,
	backgroundcolor=\color{white},
	keywordstyle=\bfseries\color{green!40!black},
	commentstyle=\itshape\color{purple!40!black},
	identifierstyle=\color{blue},
	stringstyle=\color{orange},
	classoffset=1,% starting a new class
%	alsoletter=\#,
	otherkeywords={\#MPC\_BEGIN, \#MPC\_END, \#MPC\_INCLUDE, \#MPC\_PROFILER\_BEGIN, \#MPC\_PROFILER\_COUNT, \#MPC\_PROFILER\_END, \#MPC\_PROFILER\_PRINT},	
	morekeywords=[2]{\#MPC\_BEGIN,\#MPC\_END},
	keywordstyle=[2]\bfseries\color{orange},
	morekeywords=[3]{\#MPC\_PROFILER\_BEGIN, \#MPC\_PROFILER\_COUNT, \#MPC\_PROFILER\_END, \#MPC\_PROFILER\_PRINT},
	keywordstyle=[3]\bfseries\color{purple},
	morekeywords=[4]{\#MPC\_INCLUDE},
	keywordstyle=[4]\bfseries\color{red}, % not used anymore	
	morekeywords=[5]{CurrentControlPtr,CurrentControl},
	keywordstyle=[5]\bfseries\color{green!50!blue}, % not used anymore	
	morekeywords=[6]{ArchiveDataPtr,ArchiveData},
	keywordstyle=[6]\bfseries\color{green!50!red}, % not used anymore	
}
\lstdefinestyle{mym}{
	language=matlab,
	backgroundcolor=\color{white},
	basicstyle=\footnotesize\ttfamily\color{matlabtext},
	keywordstyle=\bfseries\color{matlabkeywords},
	commentstyle=\color{matlabcomments},
	morecomment=[l][\color{matlabcomments}\bfseries]{\%\%},
	morecomment=[l][\color{matlabcomments}]{...},
	identifierstyle=\color{matlabvariable},
	stringstyle=\color{matlabstring},
}

%wymiar tekstu (bez ¿ywej paginy)
\textwidth 160mm \textheight 247mm

%ustawienia pakietu pgfplots
\pgfplotsset{
tick label style={font=\scriptsize},
label style={font=\small},
legend style={font=\small},
title style={font=\small}
}

\newcommand{\AutomaticMPC}{{\scshape AutoMATiC}}

\title{\AutomaticMPC\ -- Tutorial}
\author{Patryk Chaber}
\date{\today}

\begin{document}
\maketitle

\tableofcontents
\newpage
\section{Introduction}
\section{Requirements}
This software was tested using following setup:
\begin{itemize}
\item Microsoft Windows 10 Pro
\item MATLAB 2019a
\item MinGW64 Compiler (C++)
\end{itemize}
and for the programming of the exemplary microcontroller:
\begin{itemize}
\item STM32F746IGT6 microcontroller (part of the Core7XXI evaluation board with Open7XXI-C board -- both produced by WaveShare)
\item J-Link v9.3
\item Keil uVision v5.17.0.0
\item STM32CubeMX
\end{itemize}

Despite aforementioned configuration, this software was tested with MATLAB 2017b, thus should work with any other MATLAB version in between of those two. This software should work also on Linux based operating systems, but it may require minor changes in paths notation.

\section{Installation}
To build \AutomaticMPC\ system compile its sources using \lstinline[style=mym]{mex} compiler in MATLAB with following steps:
\begin{enumerate}
\item download or clone the repository of \AutomaticMPC:\\ \url{https://github.com/pjchaber/automatic-mpc.git}
\item make sure that MATLAB is callable from the shell by executing: \label{it:shell}
\begin{lstlisting}[]
matlab -batch "disp(version);"
\end{lstlisting}
which should print output similar to the following:
\begin{lstlisting}[]
9.6.0.1072779 (R2019a)
\end{lstlisting}
If the output differs, make sure that the following MATLAB directory:
\begin{lstlisting}[]
<MATLAB root directory>\bin\win64
\end{lstlisting}
is listed in \lstinline|PATH| variable of your system. For example:
\begin{lstlisting}[]
E:\Program Files\MATLAB\R2019a\bin\win64
\end{lstlisting}
\item register MATLAB for further use of its engine executing of the following instruction in shell:\label{it:regserver}
\begin{lstlisting}[]
matlab -regserver
\end{lstlisting}
\item change current working directory to a directory with the source of the project 
\item execute in MATLAB following instruction
\begin{lstlisting}[style=mym]
mex -v -client engine main.cpp XGetOpt.cpp -output automatic_transcompiler.exe;;
\end{lstlisting}
If the compilation fails, make sure that you have set a C++ compiler by executing in MATLAB:
\begin{lstlisting}[style=mym]
mex -setup C++
\end{lstlisting}
Also make sure, to use the same MATLAB version which was used in the shell at step \ref{it:shell} and \ref{it:regserver}.
\end{enumerate}

\section{Setup}
All further examples focus on the task of controlling output voltage of emulated process. It is also done using voltage signals. All those signals range from 0 to 3.3V. From the implementation side, those signals are represented as values from -1 to 1, where the lowest value represents 0V and the highest one represents 3.3V. The process that is emulated is a matrix of single inertia transfer functions. {\color{red} Should I give an exact process definition or the code for one?}

\section{Single Algorithm in a Controller}

Firstly lets create STM32CubeMX project which will be used as a base for further definition of a target platform's configuration (it is expected from the reader to know how to use STM32CubeMX and how to create projects for STM32F746IGT6 or similar, and how to, based on such a project, generate a Keil uVision 5 project). Details of this project are as follows:
\begin{itemize}
	\item Target Platform: STM32F746IGTx
	\item Pinout and Configuration:
	\begin{itemize}
		\item RCC (HSE as Crystal/Ceramic Resonator)
		\item ADC3 (IN0 and IN1 enabled):
		\begin{itemize}
			\item Clock Prescaler: PLCK divided by 4
			\item Scan Conversion: Enabled
			\item Continuous Conversion: Enabled
			\item DMA Continuous Requests: Enabled
			\item Number of Regular Conversions: 2
			\item Rank 1:
			\begin{itemize}
				\item Channel: Channel 0
				\item Sampling Time: 144 Cycles
			\end{itemize}
			\item Rank 2:
			\begin{itemize}
				\item Channel: Channel 1
				\item Sampling Time: 144 Cycles
			\end{itemize}
		\end{itemize}
		\item DAC (OUT1 and OUT2 enabled), for both outputs:
		\begin{itemize}
			\item  Output Buffer: Enable
			\item  Trigger: None
		\end{itemize}
		\item TIM2 (Clock Source: Internal Clock):
		\begin{itemize}
			\item Prescaler: 1000-1
			\item Counter Period: 10800
		\end{itemize}
		\item TIM5 (Clock Source: Internal Clock):
		\begin{itemize}
			\item Prescaler: 0
			\item Counter Period: 0xffffffff
		\end{itemize}
		\item USART1 (Asynchronous):
		\begin{itemize}
			\item Data Direction: Transmit Only
		\end{itemize}
		\item DMA2
		\begin{itemize}
			\item ADC3:
			\begin{itemize}
				\item Stream: DMA2 Stream 0
				\item Direction: Peripheral to Memory
				\item Priority: Low
				\item Mode: Circular
				\item Peripheral Data Width: Word
				\item Memory Data Width: Word
			\end{itemize}
			\item ADC3:
			\begin{itemize}
				\item Stream: DMA2 Stream 0
				\item Direction: Peripheral to Memory
				\item Priority: Low
				\item Mode: Circular
				\item Peripheral Data Width: Word
				\item Memory Data Width: Word
			\end{itemize}
		\end{itemize}
		\item NVIC:
		\begin{itemize}
			\item Time base of System tick Timer (Preemption Priority: 5)
			\item ADC1, ADC2 and ADC3 global interrupts (Enable, Preemption Priority: 3)
			\item TIM2 global interrupts (Enabled, Preemption Priority: 1)
			\item USART1 global interrupts (Enabled)
			\item DMA2 stream0 global interrupts (Preemption Priority: 4)
		\end{itemize}
	\end{itemize}
	\item Clock Configuration:
	\begin{itemize}
		\item Input Frequency for HSE: 8Hz
		\item PLL Source Mux: HSE
		\item HCLK (MHz): 216 (confirm by pressing ENTER)
	\end{itemize}
	\item Project Manager:
	\begin{itemize}
		\item Toolchain / IDE: MDK-ARM V5
		\item Minimum Heap Size: 0x8000
		\item Minimum Stack Size: 0x40000
	\end{itemize}
\end{itemize}

After generating code to a Keil uVision 5 project communication interface with the PC and interface to connect process of control has to be implemented. It is worth making sure, that all the code, that is added to the project after its generation is placed between comments \lstinline[style=myc]|/* USER CODE BEGIN <name> */| and \lstinline[style=myc]|/* USER CODE END <name> */|, which will further on be denoted as "\textless name\textgreater" block. It will further ease the process of regeneration of the microcontroller's configuration.

\subsection{Communication with PC using USART}
Firstly, in the \lstinline[]|main.c| file, \lstinline|string.h| library header has to be included in the "Includes" block. This will allow to send text messages to a PC in a simple manner. Next a simple wrapper for transmitting of a string should be defined in block "0":
\begin{lstlisting}[style=myc]
void write_string(char * txt){
	while(HAL_UART_GetState(&huart1) == HAL_UART_STATE_BUSY_TX);
	if(HAL_UART_Transmit_IT(&huart1, (uint8_t*)txt, strlen(txt))!= HAL_OK) 
		Error_Handler();  
	while(HAL_UART_GetState(&huart1) == HAL_UART_STATE_BUSY_TX);
}
\end{lstlisting}

At this point, it is possible to send text messages to a PC, it is worth noting, that the new line character and carriage return is not included by default in the sent string.
\subsection{Measuring Voltage Signal}
Voltage signals after conversion to a digital values will be averaged over 100 consecutive samples. Therefore a table for those raw measurements have to be defined in block "PV" as:
\begin{lstlisting}[style=myc]
uint32_t adc_val_raw[ADC_SIZE*2] = {0};
\end{lstlisting}
where \lstinline[style=myc]|ADC_SIZE| is defined in block "PD" as:
\begin{lstlisting}[style=myc]
#define ADC_SIZE 100
\end{lstlisting}
Due to having two signals, the size of table with raw measurements is \lstinline[style=myc]|ADC_SIZE*2|. To increase the resolution of averaged measurements, those will be stored as \lstinline[style=myc]|float| variables (block "PV"):
\begin{lstlisting}[style=myc]
float adc_val_f[2] = {0,0};
\end{lstlisting}

Having those defined, it is important to start a ADC unit. It can be implemented by inserting following code into a block "2":
\begin{lstlisting}[style=myc]
HAL_ADC_Start(&hadc3);
if(HAL_ADC_Start_DMA(&hadc3, (uint32_t*)adc_val_raw, ADC_SIZE*2) != HAL_OK) Error_Handler();
\end{lstlisting}

Thanks to a DMA mechanism, after obtaining 100 consecutive samples of each signal a specific callback function will be executed. It can be redefined to perform measurements' averaging as soon as they are available, by inserting following code in block "0":
\begin{lstlisting}[style=myc]
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* AdcHandle)
{
	static int i=0; 
	static uint32_t tmpval[2] = {0,0};
	for(i=0,tmpval[0]=0,tmpval[1]=0;i<ADC_SIZE; ++i){
		tmpval[0] += adc_val_raw[2*i];
		tmpval[1] += adc_val_raw[2*i+1];
	}
	adc_val_f[0] = ((float)tmpval[0]/ADC_SIZE-2047.5f)/2047.5f;
	adc_val_f[1] = ((float)tmpval[1]/ADC_SIZE-2047.5f)/2047.5f;
}
\end{lstlisting}
This will allow to have constant supply of averaged results from ADC without consuming much of a computational power of a microcontroller core (thanks to DMA).

\subsection{Creating Voltage Signal}
To generate voltage signal DAC are used. Those are already configured thanks to the generation of the code from STM32CubeMX, although, they have to be started before they can be used. To start them, in the block "2" there has to be invoked:
\begin{lstlisting}[style=myc]
HAL_DAC_Start(&hdac, DAC_CHANNEL_1);
HAL_DAC_Start(&hdac, DAC_CHANNEL_2);
\end{lstlisting}
A following calls allow to generate 0V on first output, and the 3.3V on the second one, since this is a 12 bit DAC:
\begin{lstlisting}[style=myc]
HAL_DAC_SetValue(&hdac, DAC1_CHANNEL_1,DAC_ALIGN_12B_R,0);
HAL_DAC_SetValue(&hdac, DAC1_CHANNEL_2,DAC_ALIGN_12B_R,4095);
\end{lstlisting}
and thus, to use this with a variable that ranges from -1 to 1, a following function is defined (in block "WHILE"):
\begin{lstlisting}[style=myc]
void __setControlValue(float* value){
  HAL_DAC_SetValue(&hdac, DAC1_CHANNEL_1,DAC_ALIGN_12B_R, (uint32_t)(value[0]*2047.5f+2047.5f));
  HAL_DAC_SetValue(&hdac, DAC1_CHANNEL_2,DAC_ALIGN_12B_R, (uint32_t)(value[1]*2047.5f+2047.5f));
}
\end{lstlisting}
where an array of two floats is an argument, and it contains values for consecutive outputs.

\subsection{Inducing Interruptions with a Constant Frequency}
To generate an interruption with a constant frequency, which will further be used as an indicator of the beginning of new discrete time, a timer TIM2 is used. It is already configured to generate events with a constant period of 100ms, but it is not started yet. To do so, a following must be implemented in a block "2":
\begin{lstlisting}[style=myc]
HAL_TIM_Base_Init(&htim2);   
HAL_TIM_Base_Start_IT(&htim2);
\end{lstlisting}
This will cause an execution of a callback function which can be redefined:
\begin{lstlisting}[style=myc]
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
    if (htim->Instance == TIM2) {
		// interrupt each 100ms
    }
}
\end{lstlisting}
Although its implementation will be further extended.
\subsection{Interface for Further Ease of Use}
At this point it is worth to create additional functions, that will wrap already existing functionality, so that anyone who will be working with this project in terms of control algorithms, will have easy interface to work with. Firstly, to give access to measurements signals a following will be used (block "0"):
\begin{lstlisting}[style=myc]
float* __measureOutput(){	
	return adc_val_f;
}
\end{lstlisting}
and it will return a pointer to a two element array of measurement values. It is clearly visible, that it is analogous to the previously defined \lstinline[style=myc]|void __setControlValue(float* value)| function. Those two functions have to have their declarations in the header file corresponding to the source file in which they are defined (block "EFP" in \lstinline|main.h|). In this header, it could be convenient to declare also a function for communication with a PC \lstinline[style=myc]|void write_string(char * txt)|.

Because the main function of the program (namely \lstinline[style=myc]|int main(void)|) is defined in the \AutomaticMPC\ system software framework, the existing one have to be redefined using another name, e.g. \lstinline[style=myc]|void low_lvl_main(void)|, which of course also has to be accessible from other source files. Therefore its declaration has to be given in a proper header file.

At the end it will be convenient to set up the Keil uVision 5 project in such a way, the transcompilation process is executed always right before the build process starts. For this, "Options for Target" window has to be opened, and in the "User" tab, in "Before Build/Rebuild" a "Run \#1" has to be filled with an execution of the transcompiler. A following will be used:
\begin{lstlisting}
<absolute path to AutoMATiC>/automatic_transcompiler.exe -I -p -d -i ../Src/main.mpc -o ../Src/main_mpc.c -l <absolute path to AutoMATiC>/Libs/MATLAB/ -L <absolute path to AutoMATiC>/Libs/C/
\end{lstlisting}
It is worth noting, that the transcompiler is executed while being in the directory with a project file (i.e. \lstinline|MDK-ARM|). Consecutive arguments of the \lstinline|automatic_transcompiler.exe| execution denotes:
\begin{itemize}
\item \lstinline|-I| -- usage of the interrupt based software framework variant,
\item \lstinline|-p| -- usage of the profiler,
\item \lstinline|-d| -- usage of the forced delay of the control signal application,
\item \lstinline|-i <path>| -- relative path to the input file used for transcompilation,
\item \lstinline|-o <path>| -- relative path to the output file storing the result of transcompilation,
\item \lstinline|-l <path>| -- relative path to the directory with MATLAB libraries of the transcompiler,
\item \lstinline|-L <path>| -- relative path to the directory with C libraries of the transcompiler.
\end{itemize}

To complete the setup of the project one has to add source files and headers of \AutomaticMPC\ system to a project for further compilation. All these files can be found in a directory \lstinline|<absolute path to AutoMATiC>/Libs/C/|. Also a file named \lstinline|main.mpc| has to be created and placed in the \lstinline|../Src/| directory. This file will contain all the logic of the controller with as few low level implementation parts as possible.

\subsection{Logic of the Controller}
The file that contains logic of the controller, namely \lstinline|main.mpc|, contains implementations which can be divided in a few parts:
\begin{itemize}
\item utilisation of the low level interface functions,
\item invoke of the MATLAB script, used for automatic code generation of the MPC algorithm,
\item implementation of controllers behaviour.
\end{itemize}
The execution of the MATLAB script is not necessary -- content of this script could be as well placed right here. This notation nevertheless allows for clearer separation of the aforementioned parts of implementation of this file:

\begin{lstlisting}[style=myc]
#include "stm32f7xx_hal.h"
#include <string.h>
#include "main.h"
#include "mat_lib.h"

long get_time(){ return HAL_GetTick(); }

extern void timer_loop(void);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){
    if (htim->Instance == TIM2) {
        timer_loop();
    }
}
void measurements(){
    #MPC_PROFILER_BEGIN 4
    new_output(&ad,__measureOutput());
    #MPC_PROFILER_END 4
}
void controls(){
    #MPC_PROFILER_BEGIN 3
    __setControlValue(last_control(&ad));
    #MPC_PROFILER_END 3
}
void hardware_setup(){
    #MPC_PROFILER_BEGIN 1
    low_lvl_main();
    #MPC_PROFILER_END 1
}

#MPC_BEGIN
\end{lstlisting}
\begin{lstlisting}[style=mym]
% Here is the MATLAB code
algorithms_parameters_definitions
\end{lstlisting}
\begin{lstlisting}[style=myc]
#MPC_END

ArchiveData ad;
CurrentControl cc;

void controller_setup(){
    #MPC_PROFILER_BEGIN 2
    init_archive_data(&ad, 200, 200, U_SIZE, Y_SIZE, 0, 0, 0.01);
    init_current_control(&cc,&ad);
    controller(NULL,NULL);
    #MPC_PROFILER_END 2
}

void idle(){
    #MPC_PROFILER_BEGIN 13
    const int k = 0;
	static char str[1000] = {0};

    sprintf(str, "x = [%f,%f,",ad.y[k][0], ad.y[k][1]);    write_string(str);
    sprintf(str,      "%f,%f,",ad.z[0], ad.z[1]);          write_string(str);
    sprintf(str,      "%f,%f,",ad.u[k-1][0],ad.u[k-1][1]); write_string(str);
    write_string("];\n\r");
    #MPC_PROFILER_END 13
}

void loop(){
    #MPC_PROFILER_BEGIN 10
    static int i = 0;
	if(i<  50){ ad.z[0] = -0.1; ad.z[1] =  0.2; }
	else      { ad.z[0] =  0.1; ad.z[1] = -0.2; }
    if(++i > 100) i = 0;
	
    #MPC_PROFILER_BEGIN 50
	controller(&ad,&cc);
	#MPC_PROFILER_END 50
	
    push_current_controls_to_archive_data(&cc,&ad);	
    #MPC_PROFILER_END 10		
}

void timeout(){
    while(1);
}
\end{lstlisting}

On the listing, there is a reference to a function called \lstinline[style=myc]|controller|, which declaration is as follows:
\begin{lstlisting}[style=myc]
void controller(ArchiveData * ad, CurrentControl * c);
\end{lstlisting}
This function will be generated as soon as the MATLAB script is finished.

The \AutomaticMPC\ system software framework assumes that there is an implementation of functions:
\begin{itemize}
\item \lstinline[style=myc]|void write_string(char * str);| -- function used by the profiler to write out the results of its measurements,
\item \lstinline[style=myc]|long get_time(void);|  -- function used by the profiler to measure time of execution,
\item \lstinline[style=myc]|void hardware_setup(void);| -- function used to setup hardware configuration of the controller,
\item \lstinline[style=myc]|void controller_setup(void);| -- function used to setup software configuration of the controller,
\item \lstinline[style=myc]|void measurements(void);| -- function used to obtain measurements for the current controller iteration,
\item \lstinline[style=myc]|void loop(void);| -- function used to define the behaviour of the controller -- here control algorithms are executed,
\item \lstinline[style=myc]|void controls(void);| -- function used to determine what to do with results obtained from consecutive control algorithms,
\item \lstinline[style=myc]|void idle(void);| -- function used for other, lower prioritized procedures,
\item \lstinline[style=myc]|void timeout(void);| -- function executed when the iteration lasts longer than the sampling period.
\end{itemize}
These functions are used in the framework, in the predefined order. If some of these are not implemented, a default (often empty) implementation is assumed.

To implement interrupt based variant of the software framework, a function
\begin{lstlisting}[style=myc]
extern void timer_loop(void);
\end{lstlisting}
has to be declared, and called each time a new discrete time instant starts. In these examples it occurs each time, the timer TIM2 generates an interrupt, and thus causes execution of the following function:
\begin{lstlisting}[style=myc]
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);
\end{lstlisting}

Each new measurement has to be stored in the \lstinline[style=myc]|ArchiveData| structure, using
\begin{lstlisting}[style=myc]
void new_output(ArchiveDataPtr ad, float* y);
\end{lstlisting}
function. Also the final values of new control signals have to be stored in the same structure using 
\begin{lstlisting}[style=myc]
void push_current_controls_to_archive_data(CurrentControlPtr c,ArchiveDataPtr ad);
\end{lstlisting}
where \lstinline[style=myc]|CurrentControl| structure is filled by each control algorithm.

Lastly, there are a few functions in the \lstinline[style=myc]|void controller_setup()| function, that are necessary to use those two structures. A function 
\begin{lstlisting}[style=myc]
void init_archive_data(ArchiveDataPtr ad, 
	long number_of_u, long number_of_y, 
	long size_of_u, long size_of_y, 
	float default_u, float default_y, 
	float current_yzad);
\end{lstlisting}
is used to initialize the \lstinline[style=myc]|ArchiveData| instance. First argument is a pointer to this structure instance, next there are two parameters used to define number of control and output signals (in this order) of the process of control. Further there are two values that determine, how many previous values of control and output signals have to be stored in the memory of the controller. At the end, there are default values of control, output and set-point signal, used for initialization of the microcontroller memory -- those can be changed as soon as the initialization function is finished.

Next function is
\begin{lstlisting}[style=myc]
void init_current_control(CurrentControlPtr cc, ArchiveDataPtr ad);
\end{lstlisting}
which is used to allocate memory for an instance of \lstinline[style=myc]|CurrentControl| based on the data stored in the alreaty setup \lstinline[style=myc]|ArchiveData| instance.

At the end of the software setup, there is an execution of the controller function, with both parameters set to \lstinline[style=myc]|NULL|, which is used to initialize some values of the controller that are constant through its whole existence -- this will be clear as soon as the generated code of the algorithm appears.

\subsection{Dynamic Matrix Control -- Analytic version}
\subsection{Dynamic Matrix Control -- Numeric version}
\subsection{Generalized Predictive Control -- Analytic version}
\subsection{Generalized Predictive Control -- Numeric version}

\section{Multiple Algorithms in a Controller}
\subsection{Analytic and Numeric versions of DMC}

\section{Extending of the Library}
\subsection{Proportional-Integral-Derivative Controller}

%\appendix
%\section{}
\end{document}

